---
title: "Cross-Selling im Banking (ced1)"
author: "Marius Läubli, Yvo Keller"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_notebook:
    toc: yes
    toc_float: true
  bookdown::html_document2:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    editor_options:
    chunk_output_type: console
  bookdown::gitbook: default
---

# Aufgabenstellung
Eine tschechische Bank möchte ihre Dienstleistungen für Privatkunden verbessern und "interessante Kundengruppen" identifizieren. Die Geschäftsleitung hat keine präzise Vorstellung, möchte jedoch zusätzliches Business generieren ohne unnötige Risiken einzugehen und Verluste einzufahren.

Die Bank denkt, dass mit Hilfe von Data Science Informationen aus dem bestehenden Kundenstamm herausgeschält werden können und liefert einen Datenextrakt aus der zentralen Datenbank. Dieser enthält Informationen zu Kunden, Produktbesitz und -nutzung (z.B. Kreditvolumen, Zahlungen, Daueraufträge und Kreditkarten), Filialnetz sowie soziodemographische Informationen.

# Creating Environment
## Installation of packages
Installing FactoMineR and factoextra via R console:

- run `install.packages(c("FactoMineR", "factoextra"))`

Installing ggbiplot via R console:

- run `install.packages(cli)`
- run `install.packages(devtools)`
- load devtools in console: `library(devtools)`
- run `install_github("vqv/ggbiplot")`

## Importing nessecary libraries
```{r load-libraries}
library(scales)
library(lubridate)

library(ggbiplot) # for PCA plotting
library(GGally) # for correlation plotting 

library(FactoMineR)
library(factoextra)
library(clustertend)

library(rpart)
library(rpart.plot)

library(tidyverse)
```

## Importing data
```{r import-data}
df_account <- read.table("xselling_banking_data/account.csv",
                         header = TRUE,
                         sep = ";")
df_card <- read.table("xselling_banking_data/card.csv",
                      header = TRUE,
                      sep = ";")
df_client <- read.table("xselling_banking_data/client.csv",
                        header = TRUE,
                        sep = ";")
df_disp <- read.table("xselling_banking_data/disp.csv",
                      header = TRUE,
                      sep = ";")
df_district <- read.table("xselling_banking_data/district.csv",
                          header = TRUE,
                          sep = ";")
df_loan <- read.table("xselling_banking_data/loan.csv",
                      header = TRUE,
                      sep = ";")
df_order <- read.table("xselling_banking_data/order.csv",
                       header = TRUE,
                       sep = ";", na.strings = c("", "NA"))
df_trans <- read.table("xselling_banking_data/trans.csv",
                       header = TRUE,
                       sep = ";")
```

# Data preprocessing
Für das Data Preprocessing schauen wir uns in einem ersten Schritt alle Daten an, die uns die Bank zur Verfügung gestellt hat. Wir prüfen den Variablentyp und überlegen uns jeweils, wie diese Daten im Gesamtkontext des Cross-Sellings hilfreich werden könnten.

Anschliessend importieren wir die Daten, wandeln Werte in ihren korrekten Variabel Typ um, benennen um für bessere Lesbarkeit und bereinigen wo notwendig.

## Preprocessing df_client
Der Datensatz df_client ist verbunden mit Disposition und wird dort unterschieden in Kontobesitzer und Kontobenutzer. Wir haben hier also auch reine Benutzer als Kunden. Ob Alter und Geschlecht ein Einfluss hat, werden wir anhand Plots genauer analysieren. Für die Junior Karte wird es möglicherweise ausschlaggebend sein.

| Variable     | Data Type | Variable Quantity | Variable Type | Variable Scale | Relevance for Cross-Selling Analysis                                                                                         |
| ------------ | --------- | ----------------- | ------------- | -------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| client\_id   | int       | qualitative       | non-numerical | nominal        | Identifies client                                                                                                            |
| district\_id\_client | int       | qualitative       | non-numerical | nominal        | Link to disctrict the client is registered in                                                                                |
| gender       | Factor    | qualitative       | non-numerical | nominal        | Could influence a lot of factors, as equal rights were not that far progressed in 1990s Czech Republic, needs to be analyzed |
| dob          | Date      | quantitative      | continous     | ratio          | Financial fortune usually rises with age                                                                                     |
| age          | int       | quantitative      | discrete      | ratio          | Financial fortune usually rises with age                                                                                     |

```{r prep-df_client}
df_client_prep <- df_client

# generate gender based on birth_number, female if +50 is added to MM of YYMMDD
df_client_prep <- df_client_prep %>%
  mutate(gender = as.factor(if_else(
    substr(birth_number, 3, 4) > 50,
    'female',
    'male'
  )))

# generate correct DOB for male & female YYMMDD
df_client_prep <- df_client_prep %>%
  mutate(dob = if_else(
    substr(birth_number, 3, 4) > 50,
    paste0(
      substr(birth_number, 1, 2), 
      formatC(substr(birth_number, 3, 4) %>% as.integer %>% - 50, width = 2, format = "d", flag = "0"), 
      substr(birth_number, 5, 6)),
    birth_number %>% as.character()
  )) %>%
  mutate(dob = paste0("19", substr(dob, 1, 2), "-", substr(dob, 3, 4), "-", substr(dob, 5, 6))) %>%
  mutate(dob = as.Date(dob, "%Y-%m-%d"))

# generate age based on DOB, attention to year of data extraction: 1999
df_client_prep <- df_client_prep %>% mutate(age = as.integer(99 - as.integer(substr(birth_number, 1, 2))))

# remove unused columns & rename
df_client_prep <- df_client_prep %>%
  select(-c(birth_number)) %>%
  rename(district_id_client = district_id)
```

## Preprocessing df_district
Die Daten in df_district beschreiben unterschiedliche Eigenschaften für jedes tschechischen Bezirk in den 1990er Jahren.
Viele Angaben darin sind vermutlich für dieses Projekt nicht sehr hilfreich. Wo Personen wohnen, sagt nicht zwingend etwas darüber aus, wo sie Arbeiten. Umzüge werden nicht beachtet.
Wenn jemand nah der Grenze wohnt, hat er/sie evtl. mehr mit dem angrenzenden Bezirk zu tun, als mit dem eigenen.


| Variable            | Data Type | Variable Quantity | Variable Type | Variable Scale | Relevance for Cross-Selling Analysis                                                                                           |
| ------------------- | --------- | ----------------- | ------------- | -------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| district\_id        | int       | qualitative       | non-numerical | nominal        | Identifies observation                                                                                                         |
| district\_name      | Factor    | qualitative       | non-numerical | nominal        | Not relevant, is a name                                                                                                        |
| population          | int       | quantitative      | continous     | ratio          | Population is only defined by the drawn border, and therefore is not likely to be relevant for a specific client               |
| region              | chr       | qualitative       | non-numerical | nominal        | Not relevant, is a name                                                                                                        |
| mun\_to\_499        | int       | quantitative      | continous     | ratio          | Villages until 499 citizens, possible correlation with income of clients, as that is generally higher in cities                |
| mun\_500\_to\_1999  | int       | quantitative      | continous     | ratio          | Villages 500 until 1999 citizens, possible correlation with income of clients, as that is generally higher in cities           |
| mun\_2000\_to\_9999 | int       | quantitative      | continous     | ratio          | Villages 2000 until 9999 citizens, possible correlation with income of clients, as that is generally higher in cities          |
| mun\_from\_10000    | int       | quantitative      | continous     | ratio          | Villages from 10'000 citizens, possible correlation with income of clients, as that is generally higher in cities              |
| no\_cities          | int       | quantitative      | continous     | ratio          | As districts have different sizes, this absoulte value is not relevant, urban\_ratio is relative and has a higher significance |
| urban\_ratio        | num       | quantitative      | continous     | ratio          | Possible correlation with income of clients, as that is generally higher cities                                                |
| avg\_salary         | int       | quantitative      | continous     | ratio          | Could indicate the general salary level of clients in that area, but as many people commute for work, it looses significance   |
| unemploy\_rate95    | num       | quantitative      | continous     | ratio          | Could indicate higher risk of debt, but can't be generally applied to clients                                                  |
| unemploy\_rate96    | num       | quantitative      | continous     | raito          | Could indicate higher risk of debt, but can't be generally applied to clients                                                  |
| enterpren\_rate     | int       | quantitative      | continous     | ratio          | Could indicate more self-employed people, but can't be generally applied to clients                                            |
| crimes\_95          | int       | quantitative      | continous     | ratio          | Could indicate poverty of a region, as violence rises with poverty, but can't be generally applied to clients                 |
| crimes\_96          | int       | quantitative      | continous     | ratio          | Could indicate poverty of a region, as violence rises with poverty, but can't be generally applied to clients                 |

```{r prep-df_district}
df_district_prep <- df_district

# renaming the columns of district for a better overview
df_district_prep <- df_district %>%
  transmute(
    district_id = A1,
    district_name = as.factor(A2),
    region = as.factor(A3),
    population = A4,
    mun_to_499 = A5,
    mun_500_to_1999 = A6,
    mun_2000_to_9999 = A7,
    mun_from_10000 = A8,
    no_cities = A9,
    urban_ratio = A10,
    avg_salary = A11,
    unemploy_rate95 = as.numeric(A12),
    unemploy_rate96 = as.numeric(A13),
    enterpren_rate = A14,
    crimes_95 = as.integer(A15),
    crimes_96 = as.integer(A16)
  )
```

## Preprocessing df_loan
Hier wird aufgezeigt, welcher "account" was für einen Loan bei der Bank hat. Pro Account kann es nur einen Loan geben. Loans sind für Cross-Selling sicherlich relevant, es ist ein Produkt welches verkauft werden kann, jedoch auch risikobehaftet ist.

Es macht also Sinn, die bestehenden Loans zu analysieren und zu versuchen, die Voraussetzungen für gute oder schlechte Verläufe zu finden.

| Variable      | Data Type | Variable Quantity | Variable Type | Variable Scale | Relevance for Cross-Selling Analysis                                                       |
| ------------- | --------- | ----------------- | ------------- | -------------- | ------------------------------------------------------------------------------------------ |
| loan\_id      | int       | Qualitative       | non-numerical | nominal        | Identifies observation                                                                     |
| account\_id   | int       | Qualitative       | non-numerical | nominal        | Identifies related observation                                                             |
| date          | date      | Quantitative      | continuous    | ratio          | Date when loan was given (to determine the situation when the loan is given)               |
| amount        | int       | Quantitative      | continuous    | ratio          | Amount of the loan, kind of relevant (what amounts were given to what clients)             |
| duration      | int       | Quantitative      | continuous    | ratio          | Amount of months indicating the duration of the loan                                       |
| monthly\_rate | int       | Quantitative      | continuous    | ratio          | Relevant if wanted in detail - can check what amounts are applicable to what situations    |
| status        | chr       | Qualitative       | non-numerical | nominal        | Relevant: current status of loan - can be used to check, what situations lead to bad stati |

```{r prep-df_loan}
df_loan_prep <- df_loan

# renaming the values
df_loan_prep <- df_loan_prep %>% 
    mutate(status = replace(status, status == "A", "finished_ok")) %>% 
    mutate(status = replace(status, status == "B", "finished_nok")) %>% 
    mutate(status = replace(status, status == "C", "running_ok")) %>% 
    mutate(status = replace(status, status == "D", "running_nok")) %>% 
    mutate(date = paste0(substr(as.character(date), 1, 2), "-", substr(as.character(date), 3, 4), "-", substr(as.character(date), 5, 6))) %>%
    mutate(date = as.Date(date, "%y-%m-%d"), monthly_rate = as.integer(payments))
```

## Preprocessing df_trans
Die Transaktionstabelle ist extrem wichtig für das Projekt, jedoch müssen nicht alle Attribute gleich gewichtet werden. Wir können damit die Entwicklung des Vermögens jedes Kunden herleiten.

| Variable    | Data Type | Variable Quantity | Variable Type | Variable Scale | Relevance for Cross-Selling Analysis                                                                                  |
| ----------- | --------- | ----------------- | ------------- | -------------- | --------------------------------------------------------------------------------------------------------------------- |
| trans\_id   | int       | Qualitative       | non-numerical | nominal        | Identifies observation                                                                                                |
| account\_id | int       | Qualitative       | non-numerical | nominal        | Identifies related observation                                                                                        |
| date        | date      | Quantitative      | continuous    | ratio          | Date when transaction took place                                                                                      |
| type        | chr       | Qualitative       | non-numerical | nominal        | Credit/withdrawal , very relevant                                                                                     |
| operation   | chr       | Qualitative       | non-numerical | nominal        | Not always given, gives a hint in individual observations but can not be used in general analytics                    |
| amount      | int       | Quantitative      | continuous    | ratio          | Amount of the transaction                                                                                             |
| balance     | int       | Quantitative      | continuous    | ratio          | Balance after the transaction                                                                                         |
| k\_symbol   | chr       | Qualitative       | non-numerical | nominal        | A sort of comment, also gives a hint in individual observations but cannot be used because of too many missing values |
| bank        | chr       | Qualitative       | non-numerical | nominal        | Information of the other bank (sending or recieving) irrelevant for this project                                      |
| account     | int       | Qualitative       | non-numerical | nominal        | Information of the other bank (sending or recieving) irrelevant for this project                                      |

```{r prep-df_trans}
df_trans_prep <- df_trans

# renaming the values
df_trans_prep <- df_trans_prep %>% 
    mutate(type = replace(type, type == "PRIJEM", "credit")) %>% 
    mutate(type = replace(type, type == "VYDAJ", "withdrawal")) %>% 
    mutate(operation = replace(operation, operation == "VYBER KARTOU", "credit_card_withdrawal")) %>% 
    mutate(operation = replace(operation, operation == "VKLAD", "credit_cash")) %>% 
    mutate(operation = replace(operation, operation == "PREVOD Z UCTU", "collection_other_bank")) %>% 
    mutate(operation = replace(operation, operation == "VYBER", "cash_withdrawal")) %>% 
    mutate(operation = replace(operation, operation == "PREVOD NA UCET", "remittance_other_bank")) %>% 
    mutate(k_symbol = replace(k_symbol, k_symbol == "POJISTNE", "insurance_payment")) %>% 
    mutate(k_symbol = replace(k_symbol, k_symbol == "SLUZBY", "statement_payment")) %>% 
    mutate(k_symbol = replace(k_symbol, k_symbol == "UROK", "interest_credited")) %>% 
    mutate(k_symbol = replace(k_symbol, k_symbol == "SANKC. UROK", "sanctioned_interest_neg_balance")) %>% 
    mutate(k_symbol = replace(k_symbol, k_symbol == "SIPO", "household")) %>% 
    mutate(k_symbol = replace(k_symbol, k_symbol == "DUCHOD", "old_age_pension")) %>% 
    mutate(k_symbol = replace(k_symbol, k_symbol == "UVER", "loan_payment")) %>% 
    mutate(date = paste0(substr(as.character(date), 1, 2), "-", substr(as.character(date), 3, 4), "-", substr(as.character(date), 5, 6))) %>%
    mutate(date = as.Date(date, "%y-%m-%d"))

df_trans_prep <- df_trans_prep %>% mutate(amount = as.integer(amount), balance = as.integer(balance))
```

## Preprocessing df_account
Diese Tabelle ist nicht reich an wertvollen Attributen, aber wird für die Verknüpfung von Tabellen benötigt.

| Variable     | Data Type | Variable Quantity | Variable Type | Variable Scale | Relevance for Cross-Selling Analysis                                                                     |
| ------------ | --------- | ----------------- | ------------- | -------------- | -------------------------------------------------------------------------------------------------------- |
| account\_id  | int       | qualitative       | non-numerical | nominal        | Identifies account                                                                                       |
| district\_id\_branch | int       | qualitative       | non-numerical | nominal        | Link to disctrict the account is registered in                                                           |
| frequency    | Factor    | qualitative       | non-numerical | nominal        | Bank statement frequency, highly unlikely to be relevant                                                 |
| date         | Date      | quantitative      | continous     | ratio          | Account opening date, could be a loyality indicator, but as we only have a few years of data, rather not |

```{r prep-df_account}
df_account_prep <- df_account
# translating to English for better understanding
df_account_prep <- df_account_prep %>%
  mutate(frequency = replace(frequency, frequency == "POPLATEK MESICNE", "monthly_issuance")) %>%
  mutate(frequency = replace(frequency, frequency == "POPLATEK TYDNE", "weekly_issuance")) %>%
  mutate(frequency = replace(frequency, frequency == "POPLATEK PO OBRATU", "issuance_after_transaction")) %>%
  mutate(frequency = as.factor(frequency)) %>%
  mutate(date = paste0(substr(as.character(date), 1, 2), "-", substr(as.character(date), 3, 4), "-", substr(as.character(date), 5, 6))) %>%
  mutate(date = as.Date(date, "%y-%m-%d")) %>%
  rename(district_id_branch = district_id)
```

## Preprocessing df_order
Daueraufträge sehen wir als uninteressant für das Cross-Selling. Es ist nicht ganz klar, ob sie als Produkt gewertet werden können. Eventuell werden bei gewissen Konten auch regelmässige Zahlungen gemacht ohne Dauerauftrag, und wenn es dabei nicht um Transkationen ins Ausland geht, kann auch kein Geld mit Gebühren verdient werden.

| Variable          | Data Type | Variable Quantity | Variable Type | Variable Scale | Relevance for Cross-Selling Analysis                                           |
| ----------------- | --------- | ----------------- | ------------- | -------------- | ------------------------------------------------------------------------------ |
| order\_id         | int       | Qualitative       | non-numerical | nominal        | Identifies observation                                                         |
| account\_id       | int       | Qualitative       | non-numerical | nominal        | Identifies related observation                                                 |
| bank\_to          | chr       | Qualitative       | non-numerical | nominal        | Identifies recieving bank, irrelevant                                          |
| account\_to       | int       | Qualitative       | non-numerical | nominal        | Identifies reciecing account, irrelevant                                       |
| amount            | int       | Quantitative      | continuous    | ratio          | Amount of monthly transaction, relevant                                        |
| payment\_category | chr       | Qualitative       | non-numerical | nominal        | payment\_category, not always given, not nessecarily relevant for this project |

```{r prep-df_order}
df_order_prep <- df_order

# translating to English for better understanding
df_order_prep <- df_order_prep %>%
  rename(payment_category = k_symbol) %>%
  mutate(
    payment_category = recode(
      payment_category,
      "SIPO" = "household",
      "UVER" = "loan",
      "LEASING" = "leasing",
      "POJISTNE" = "insurance",
      " " = "missing"
    ), amount = as.integer(amount)
  )
```

## Preprocessing df_card
Wie der Loan, sind auch die Kreditkarten ein Produkt mit viel Bedeutung für Cross-Selling, und stellen in diesem Projekt für und das Fokusprodukt dar.

Hier wollen wir vor und nach der Herausgabe der Kreditkarte die Vermögensentwicklung analysieren, und aufgrund diesen Informationen versuchen, low-risk Ausgangslagen zu finden.

| Variable | Data Type | Variable Quantity | Variable Type | Variable Scale | Relevance for Cross-Selling Analysis |
| -------- | --------- | ----------------- | ------------- | -------------- | ------------------------------------ |
| card\_id | int       | Qualitative       | non-numerical | nominal        | Identifies observation               |
| disp\_id | int       | Qualitative       | non-numerical | nominal        | Identifies related observation       |
| type     | chr       | Qualitative       | non-numerical | ordinal        | Type of card, very relevant          |
| issued   | date      | Quantitative      | continuous    | ratio          | Date of issuance, very relevant      |

```{r prep-df_card}
df_card_prep <- df_card
df_card_prep <- df_card_prep %>%
  mutate(issued = paste0("19", substr(issued, 1, 2), "-", substr(issued, 3, 4), "-", substr(issued, 5, 6))) %>%
  mutate(issued = as.Date(issued, "%Y-%m-%d"))
```

## Preprocessing df_disp
Disponent ist eine Zwischentabelle, welche es uns erlaubt, nach den Ownern zu filtern. Wir gehen davon aus, dass Disponenten uninteressant sind für uns.
Wir können nicht feststellen, welche Transaktionen vom Owner und welche von Disponents getätigt werden, und legen uns deshalb auf den Owner fest.
Auch ist ein Disponent nur eine zusätzlich Person mit Zugriff auf ein Konto mit Owner dahinter, und die Wirtschaftlichkeit dessen ist es, was der Bank schlussendlich Profit ermöglicht.

| Variable    | Data Type | Variable Quantity | Variable Type | Variable Scale | Relevance for Cross-Selling Analysis                                                 |
| ----------- | --------- | ----------------- | ------------- | -------------- | ------------------------------------------------------------------------------------ |
| disp\_id    | int       | qualitative       | non-numerical | nominal        | Identifies disponent                                                                 |
| client\_id  | int       | qualitative       | non-numerical | nominal        | Identifies client                                                                    |
| account\_id | int       | qualitative       | non-numerical | nominal        | Identifies account                                                                   |
| type        | Factor    | qualitative       | non-numerical | ordinal        | Type of relation, e.g. account owner or disponent, will be relevant to differentiate |

```{r prep-df_disp}
df_disp_prep <- df_disp
df_disp_prep <- df_disp_prep %>%
  mutate(type = as.factor(recode(type, "OWNER" = "owner", "DISPONENT" = "disponent")))
```

# Explorative data analysis
Wir schauen uns die Daten an und visualisieren diese mittels geeigneten Plots, um ein Verständnis über die Bank und ihre Kunden zu erhalten.
Dies kann uns in der späteren Interpretation weiterführender Analysen helfen.

## Entity Relationship Model
![ERM](ERM Data Relations.jpg)
*ERM Diagramm - Aufbau und Beziehung zwischen den Kundendaten*

Beziehungen zwischen Kunden und Bankprodukten:

- Ein Account kann 0 oder 1 Darlehen haben
  - Ein Account kann dabei über die Disposition von mehreren Clients verwendet werden
- Eine Disposition (Client-Account Beziehung) kann 0 oder 1 Kreditkarte zugewiesen sein
  - Ein Client kann somit potenziell von mehreren Accounts eine Kreditkarte besitzen
- Ein Account kann 0 bis n Permanent Orders erfasst haben
  
  
## Bank Customers
### Age Distribution of the Bank Clients
Die meisten Bankkunden sind zwischen 20 und 60 Jahren Alt. Der jüngste Kunde ist 12, während der älteste 88 ist.
Der starke Anstieg zwischen 12 und 20 Jahren hängt sicherlich damit zusammen, dass man in diesem Altersbereich das erste Bankkonto benötigt.
Ab 57 Jahren lässt sich ein starker Abfall der Anzahl Kunden erkennen. Dies liesse sich z.B. dadurch erklären, dass die Bank Vorsorgekonten anbietet, und diese um das Pensionsalter herum ausbezahlt und aufgelöst werden. Der Abfall ab 75 Jahren wäre dann auf den Tod der Kunden mit zunehmendem Alter zurückzuführen.
```{r plot-bank-clients-1}
ggplot(df_client_prep, aes(x = age)) +
  geom_density() +
  labs(title = "Age Distribution of the Bank Clients", x = "Age (in Years)", y = "Density") +
  geom_vline(aes(xintercept = median(age, na.rm=TRUE)),color="darkorange", linetype="dashed") +
  geom_vline(aes(xintercept = mean(age, na.rm=TRUE)),color="deepskyblue", linetype="dashed") +
  geom_text(aes(x=median(age, na.rm=TRUE), y=0), label="Median", color = "darkorange", vjust=-.4, hjust=.0, angle = 90) +
  geom_text(aes(x=mean(age, na.rm=TRUE), y=0), label="Mean", color = "deepskyblue", vjust=-.4, hjust=.0, angle = 90) +
  geom_vline(aes(xintercept = quantile(age, 0.25, na.rm=TRUE)), color="darkolivegreen4", linetype="dotted") +
  geom_vline(aes(xintercept = quantile(age, 0.75, na.rm=TRUE)), color="darkolivegreen4", linetype="dotted") +
  geom_text(aes(x=quantile(age, 0.25, na.rm=TRUE), y=0), label="1. Quartile", color = "darkolivegreen4", vjust=-.4, hjust=.0, angle = 90) +
  geom_text(aes(x=quantile(age, 0.75, na.rm=TRUE), y=0), label="3. Quartile", color = "darkolivegreen4", vjust=-.4, hjust=.0, angle = 90) +
  theme(legend.position = "bottom") +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) +
  expand_limits(x = 0)
```

### Age Distribution of the Bank Clients by Gender
Schauen wir uns die Altersverteilung der Kunden nach Geschlecht an. Hier wird ersichtlich, dass sich diese kaum unterscheidet. Eine kleine Differenz ist bei 38 Jahren zu erkennen, um dieses Alter herum gibt es etwas mehr Männer mit Konto als Frauen. Auch nimmt die Zahl der Konten bei den Frauen bereits etwas früher wieder ab.
```{r plot-bank-clients-2}
ggplot(df_client_prep, aes(x = gender, y = age, fill = gender)) +
  geom_violin() +
  expand_limits(y = 0) +
  labs(title = "Age Distribution of the Bank Clients by Gender", x = "Gender", y = "Age (in Years)", fill = "Gender") +
  theme(legend.position = "bottom")
```

### Bank Acccounts per Branch Region in Czech Republic

> Gibt es Gebiete in Tschechien, welche von der Bank mehr erschlossen sind als andere?
> Könnten bestimmte Gebiete besser beworben, und somit auch besser erschlossen werden?

In den tschechischen Regionen Nord- und Südmoravia sind die meisten Accounts registriert. Da Bank ist also da am stärksten vertreten. Auch wird sichtbar, dass der Kontoauszug für die allermeisten Accounts monatlich ausgestellt wird.
```{r plot-bank-clients-3}
# Regions where the bank clients live
df_temp <- df_account_prep %>%
  inner_join(df_district_prep, by = c("district_id_branch" = "district_id"))

ggplot(df_temp, aes(x = region, fill = frequency)) +
  geom_bar() +
  labs(title = "Bank Acccounts per Branch Region in Czech Republic", x = "Region", y = "# Accounts", fill = "Statement Frequency") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

rm(df_temp)
```

**Schlussfolgerungen:**

Ein kurzer Abgleich mit der Bevölkerungszahl zu dem Zeitpunkt in den unterschiedlichen Regionen Tschechiens zeigt, dass ebendiese Regionen auch am meisten Einwohner haben. Es lässt sich somit sagen, dass die Bank in ganz Tschechien gut vertreten ist. Dies beantwortet unsere Frage zu beginn, ob es Gebiete gibt, welche weniger gut erschlossen sind als andere, mit: "Nein, verhältnismässig sind alle Districts etwa gleich gut erschlossen."

```{r plot-bank-clients-4}
df_temp <- df_district_prep %>%
  group_by(region) %>%
  summarize(region_population = sum(population)) %>%
  ungroup()

ggplot(df_temp, aes(x = region, y = region_population)) +
  geom_col() +
  labs(title = "Population by Regions of the Czech Republic", x = "Region", y = "Population") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
  
rm(df_temp)
```

### Bank Clients per Region in Czech Republic

> Ein Kunde kann sein Konto an einer Filiale ausserhalb seines Wohndistrikts eröffnen.
> Kommt das auch in der Realität vor, und hat das einen Einfluss auf unsere Analysen?

In den tschechischen Regionen Nord- und Südmoravia leben die meisten Bankkunden. Die Verteilung der Kunden auf die Regionen deckt sich ungefähr mit der Verteilung der Accounts aus dem vorherigen Plot. Das lässt darauf schliessen, dass die meisten Kunden ihr Konto bei einer Niederlassung in der tschechischen Region eröffnen, in der sie wohnen, oder sich diese Differenzen gegenseitig ausgleichen.

```{r plot-bank-clients-5}
# Regions where the bank clients live
df_temp <- df_client_prep %>%
  inner_join(df_district_prep, by = c("district_id_client" = "district_id"))

ggplot(df_temp, aes(x = region, fill = gender)) +
  geom_bar() +
  labs(title = "Bank Clients per Region in Czech Republic", x = "Region", y = "# Clients", fill = "Gender") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

rm(df_temp)
```

In der oben stehenden Analyse hat sich abgezeichnet, dass eine Korrelation zwischen der Einwohnerzahl und der Anzahl Konten/Kunden in den tschechischen Regionen vorliegen könnte. Wie nun der Plot zur Korrelation Analyse zeigt, liegt hier tatsächlich eine starke positive Korrelation vor.

```{r plot-bank-clients-correlation}
df_temp <- df_district_prep %>%
  group_by(region) %>%
  mutate(region_population = sum(population)) %>%
  left_join(df_client_prep, by = c("district_id" = "district_id_client")) %>%
  summarize(region_population = min(region_population), region_clients = n()) %>%
  ungroup() %>%
  select(-region)

# Check Correlation on Simple Scatter Plot
ggplot(df_temp, aes(x = region_population, y = region_clients)) +
  geom_point() +
  labs(y = "# of Clients in Region", x = "Size of Population in Region")

# Use GGplo
ggpairs(df_temp)

rm(df_temp)
```

**Schlussfolgerungen:**

- Es gibt keinen statistisch relevaten Unterschied zwischen der Anzahl Konten pro Region und der zur Anzahl Kunden, die in einer Region leben.
- Es liegt eine stark positive Korrelation zwischen der Einwohnerzahl eines Distrikts und der Anzahl Kunden, die die Bank da hat, vor.


## Bank Products
### Loans
Wir schauen uns die Darlehen (Loans) an. Diese sind ein zentrales Produkt der Bank, was Cross-Selling betrifft.

#### Loan amount distribution

> Bietet die Bank mehr kleine oder mehr grosse Darlehen an?

Die rechtsschiefe Verteilung zeigt, dass die Hälfte der Darlehen für Beträge zwischen 0 und ca. 160'000 Kč herausgegeben wurden.
Je höher der Betrag des Darlehens, desto weniger davon hat die Bank ausgestellt.

```{r plot-bank-products-1}
loan_status_colors <- c("#d61515", "#22d615", "#d315d6", "#c0d615")

ggplot(df_loan_prep, aes(x = amount)) +
  geom_density() +  
  scale_x_continuous(labels = label_number(suffix = " Kč", scale = 1e+0)) +
  labs(title = "Loan amount distribution", subtitle = "over all bank clients with a loan", x = "Amount", y = "Density") +
  geom_vline(aes(xintercept = median(amount, na.rm=TRUE)),color="darkorange", linetype="dashed") +
  geom_vline(aes(xintercept = mean(amount, na.rm=TRUE)),color="deepskyblue", linetype="dashed") +
  geom_text(aes(x=median(amount, na.rm=TRUE), y=0), label="Median", color = "darkorange", vjust=-.4, hjust=.0, angle = 90) +
  geom_text(aes(x=mean(amount, na.rm=TRUE), y=0), label="Mean", color = "deepskyblue", vjust=-.4, hjust=.0, angle = 90) +
  geom_vline(aes(xintercept = quantile(amount, 0.25, na.rm=TRUE)), color="darkolivegreen4", linetype="dotted") +
  geom_vline(aes(xintercept = quantile(amount, 0.75, na.rm=TRUE)), color="darkolivegreen4", linetype="dotted") +
  geom_text(aes(x=quantile(amount, 0.25, na.rm=TRUE), y=0), label="1. Quartile", color = "darkolivegreen4", vjust=-.4, hjust=.0, angle = 90) +
  geom_text(aes(x=quantile(amount, 0.75, na.rm=TRUE), y=0), label="3. Quartile", color = "darkolivegreen4", vjust=-.4, hjust=.0, angle = 90) +
  theme(legend.position = "bottom")
```

**Schlussfolgerungen:**

- Die Bank bietet Darlehen für kleine bis grosse Summen an.
- Die Hälfte der Darlehen wurden für Beträge zwischen 0 und ca. 160'000 Kč herausgegeben

#### Loan amount distribution by payment status

> Hypothese: Darlehen über grössere Summen werden schnell schwerer abzuzahlen, wenn das Einkommen plötzlich einbricht.
> Sie stellen dadurch ein grösseres Risiko für die Bank dar.

Betrachten wir die Grösse der Darlehen kategorisiert nach ihrem Zahlungsstatus. Hier wird ersichtlich, dass für grössere Darlehen eine leichte Tendenz besteht, dass diese nicht fristgerecht oder gar nicht abbezahlt werden.

```{r plot-bank-products-2}
ggplot(df_loan_prep, aes(x = status, y = amount, color = status)) +
  geom_violin() +
  scale_y_continuous(labels = label_number(suffix = " Kč", scale = 1e+0)) + # find correct scale!!!
  labs(title = "Loan amount distribution by payment status", subtitle = "over all bank clients with a loan", x = "Status", y = "Amount") +
  theme(legend.position = "bottom") +
  scale_color_manual(values=loan_status_colors)
```

**Schlussfolgerungen:**

- Bei Darlehen über 100'000 Kč kommt es eher mal zu Schwierigkeiten bei der Abzahlung
- Gleichzeitig können Probleme auch bei Darlehen unter 100'000 Kč nicht ausgeschlossen werden

#### Number of loans and their status

> Hypothese: Darlehen über kürzere Laufzeiten sind für die Bank ein geringereres Risiko.

Betrachten wir die Anzahl von Darlehen nach Vertragslaufzeit, so wird klar, dass im Zeitraum des Datensatzes (1993-1998) ungefähr die selbe Anzahl Darlehen für jede Laufzeit ausgestellt wurde. Je länger die Vertragslaufzeit, desto mehr Darlehen laufen noch. Dies macht insofern Sinn, dass nur Darlehen mit Start 1993 im Datensatz sind, und bis 1998 erst ein paar wenige mit Laufzeit über 60 Monate (5 Jahre) abbezahlt werden konnten. 

Gleichzeitig steigt mit der Vertragslaufzeit das Riskio für Zahlungsunfähigkeit des Kunden (running_nok) an.

```{r plot-bank-products-3}
ggplot(df_loan_prep, aes(x = factor(duration), fill = status)) +
  geom_bar() +
  labs(title = "Number of loans and their status", subtitle = "over all bank clients with a loan", x = "Duration in Months", y = "# Loans", fill = "Status") +
  scale_fill_manual(values=loan_status_colors)
```

**Schlussfolgerungen:**

- Darlehen über kürzere Laufzeiten bergen für die Bank ein geringeres Risiko, und sollten zumindest aus Risiko-Sicht bevorzugt werden.

#### Loan amount by age when taken

> Hypothese: Je jünger ein Kunde, desto höher das Risiko für Zahlungsunfähigkeit bei Anleihen.

Schauen wir uns die Grösse der Darlehen im Bezug zum Alter der Kunden bei dessen Bezug an, wird sichtbar, dass das Alter bei der Bank für die Ausgabe der Loans kaum eine Rolle gespielt hat.

```{r plot-bank-products-4}
df_client_prep1 <- df_client_prep
df_loan_prep1 <- df_loan_prep
names(df_client_prep1) <- paste0("client.", names(df_client_prep1) )
names(df_loan_prep1) <- paste0("loan.", names(df_loan_prep1) )

df_temp <- df_disp_prep %>% 
  filter(type=="owner") %>% 
  left_join(df_client_prep1, by = c("client_id"="client.client_id")) %>% 
  left_join(df_loan_prep1, by = c("account_id"="loan.account_id"))
  
rm(df_client_prep1)
rm(df_loan_prep1)


df_temp1 <- df_temp %>%
  select(client.age, client.dob, client.gender, loan.amount, loan.date, loan.status) %>%
  mutate(age_when_loan_taken = time_length(difftime(loan.date, client.dob), "years")) %>%
  na.omit()

ggplot(df_temp1, aes(x = age_when_loan_taken, y = loan.amount, color = loan.status)) +
  geom_point() +
  labs(title = "Loan amount by age when taken", x = "Age of Client when Loan taken", y = "Loan Amount", color = "Status") +
  scale_y_continuous(labels = label_number(suffix = " Kč", scale = 1e+0))

rm(df_temp1)
```

**Schlussfolgerungen:**

- Jüngere wie ältere Kunden haben grössere Darlehen erhalten.
- Der Status der Loans ist nicht klar altersabhängig bedingt, was unsere 1. Hypothese widerlegt.

#### Loan amount by duration

> Hypothese: Je länger die Vertragslaufzeit festlegelegt wird, desto grösser kann das Darlehen sein.

Es lässt sich ein linearer Anstieg der Darlehenshöhe zusammen mit der Vertragslaufzeit erkennen. Da es keine Ausreisser gibt, scheint es so, als hätte die Bank hier klare Richtlinien über Laufzeit und Höhe, die sie bei der Herausgabe von Darlehen befolgt. Auch hier zeigen sich keine Unterschiede in der Darlehenshöhe im Zusammenhang mit dem Geschlecht.

```{r plot-bank-products-5}
ggplot(df_temp, aes(x = loan.duration, y = loan.amount, color = client.gender)) +
  geom_jitter(na.rm = TRUE) +
  labs(title = "Loan amount by duration", x = "Duration", y = "Loan Amount", color = "Gender") +
  scale_y_continuous(labels = label_number(suffix = " Kč", scale = 1e+0))
```
**Schlussfolgerungen:**

- Je länger die Vertragslaufzeit, desto grösser kann die Höhe des Darlehens sein - unsere Hypothese bestätigt sich dadurch.
- Frauen wie auch Männer verfügen über Darlehen von kleinen bis grossen Summen.

### Credit Cards
Die Kreditkarte ist für die Bank ein finanziell lukratives Produkt, da mit jeder Transaktion Gebühren verdient werden können. Gleichzeitig erhöht sich traditionell das Risiko für die Verschuldung des Kunden. Wir werden auf dieses Produkt im Cross-Selling unseren Hauptfokus legen.

#### Card types per age group

> Hypothese: Je älter ein Kunde, desto seltener ist er im Besitz einer Kreditkarte, da er oft in Bar bezahlt.

```{r plot-bank-products-6}
df_client_prep1 <- df_client_prep
df_card_prep1 <- df_card_prep
names(df_client_prep1) <- paste0("client.", names(df_client_prep1) )
names(df_card_prep1) <- paste0("card.", names(df_card_prep1) )

df_temp <- df_disp_prep %>%
  filter(type=="owner") %>% 
  left_join(df_client_prep1, by = c("client_id"="client.client_id")) %>%
  left_join(df_card_prep1, by = c("disp_id"="card.disp_id"))

rm(df_client_prep1)
rm(df_card_prep1)

df_temp1 <- df_temp %>%
  select(client.age, client.dob, client.gender, card.type) %>%
  mutate(has_card = if_else(!is.na(card.type), TRUE, FALSE)) %>%
  mutate(age_sector = if_else(client.age > 0 & client.age < 11, "0+", "")) %>%
  mutate(age_sector = if_else(client.age > 10 & client.age < 21, "10+", age_sector)) %>%
  mutate(age_sector = if_else(client.age > 20 & client.age < 31, "20+", age_sector)) %>%
  mutate(age_sector = if_else(client.age > 30 & client.age < 41, "30+", age_sector)) %>%
  mutate(age_sector = if_else(client.age > 40 & client.age < 51, "40+", age_sector)) %>%
  mutate(age_sector = if_else(client.age > 50 & client.age < 61, "50+", age_sector)) %>%
  mutate(age_sector = if_else(client.age > 60 & client.age < 71, "60+", age_sector)) %>%
  mutate(age_sector = if_else(client.age > 70 & client.age < 81, "70+", age_sector)) %>%
  mutate(age_sector = if_else(client.age > 80 & client.age < 91, "80+", age_sector)) %>%
  mutate(age_sector = if_else(client.age > 90 & client.age < 101, "90+", age_sector))

ggplot(df_temp1, aes(x = age_sector, fill= card.type)) +
  geom_bar(position="fill") +
  labs(title = "Card types per age group", x = "Age group", fill = "Card Type")

rm(df_temp1)
```

**Schlussfolgerungen:**

- Ältere Kunden haben weniger Kreditkarten, es liegen jedoch auch weniger Daten zu älteren Kunden vor. Unsere Hypothese kann mit Vorbehalten in ihrer Tendenz bestätigt werden.

#### Wealth distribution per gender

> Hypothese: Weibliche Kunden haben ein kleineres Vermögen auf dem Konto"

```{r gender based wealth plotting}
# Get only owners from disposition
df_temp1 <- filter(df_disp, type=="OWNER")

# Join client to df
df_temp1 <- df_temp1 %>% 
  left_join(df_client_prep, by = "client_id") %>% 
  select(-dob)

# get transaction data frame ready for the join
# Taking the last entry of balance per account (as it is ordered by date, this is the last known balance)
df_trans_join_ready <- df_trans_prep %>%
  group_by(account_id) %>%
  summarise(final_balance = last(balance))

# join the edited, grouped df_trans to the df
df_temp1 <- df_temp1 %>%
  left_join(df_trans_join_ready, by = "account_id")

df_temp1 %>% ggplot(mapping = aes(x = gender, y = final_balance)) +
  geom_boxplot()+
  labs(title = "wealth by gender", x = "gender", y = "wealth") +
  scale_y_continuous(labels = label_number(suffix = " Kč", scale = 1e+0))

rm(df_temp1, df_trans_join_ready)
```

**Schlussfolgerungen:**

Die Vermögen von männlichen und weiblichen Kunden sind nahezu deckungsgleich, mit der Ausnahme von zwei Ausreissern, wo Männer ein grösseres Vermögen haben.

# Feature Engineering

In diesem Teil möchten wir uns der Entwicklung von neuen, aussagekräftigen Features zu den Kunden aus ihren Daten widmen. Wir werden verschiedene Methoden ausprobieren, vorhersagen in Richtung Cross-Selling und Risiko zu machen, die der Bank helfen können, ihr Business zu steigern. 

## Implementation of Credit Check

Die Idee hinter diesem Schritt ist es, einen Kredit Check durchzuführen, auf Basis von Vermögen, Einkommen und dem Status der Loans.

Für die Berechnung des regelmässigen Einkommens gehen wir wie folgt vor:

1. Es werden alle Transaktionen mit Type "Credit" angeschaut.
1. Von diesen werden die 3 sich am meisten wiederholenden Beträge verwendet.
1. Mit der Bedingung, dass solche Transaktionen mehr als 20 mal vorkommen müssen, leiten wir daraus ein geschätztes, monatliches Einkommen ab.
1. Diese Beträge werden addiert und als avg_income ausgewiesen.

ACHTUNG:
Dies ist natürlich nicht eine sichere Annahme, und sie geht von gewissen Randbedingungen aus, die mit grosser Wahrscheinlichkeit nicht auf alle Kunden/Konten zutreffen. Beispielsweise wird so das Einkommen bei jemamdem, der regelmässige Zahlungen auf sein Konto erhält, wo dies jedoch immer in unterschiedlichen Beträgen geschieht, unterschätzt. Die anschliessenden Analysen und ihre Sinnhaftigkeit zeigen dennoch, dass die Annahme zumindest in ihren Grundzügen Gültigkeit hat.

Ziel ist es, ein erstes Feature zu haben und anhand dieser Methode neue Ideen und Anregungen zu gewinnen, wie die weiteren Schritte gestaltet werden sollen.

Planned process:

  - Get only owners from disposition
  - join Credit Card to have type and then create True/False for "has Card"
  - Remove unnecessary columns
  - join age and gender from client
  - remove unnecessary columns, edit order of coulmns for readability
  - add columns based on loans, generate coulumn with count per status
  - add column based on trans, get avg from the collection_of_other banks

### Calculating Credit Check
```{r generating base df}
# Get only owners from disposition
df_credit_check<- filter(df_disp, type=="OWNER")

# Join Credit Cards to disposition, Remove unnecessary columns, Rename columns
df_credit_check <- df_credit_check %>% 
  left_join(df_card, by = "disp_id") %>% 
  select(-card_id, -issued) %>%
  rename(card_type = type.y, disp_type = type.x)

# Join client to df
df_credit_check <- df_credit_check %>% 
  left_join(df_client_prep, by = "client_id") %>% 
  select(-dob)

# Join loan to df
df_credit_check <- df_credit_check %>%
  left_join(df_loan_prep, by = "account_id")  %>%
  select(-loan_id, -amount, -duration, -monthly_rate, -date) %>%
  rename(loan_status = status)

# get transaction data frame ready for the join
# Taking the last entry of balance per account (as it is ordered by date, this is the last known balance)
df_trans_join_ready <- df_trans_prep %>%
  group_by(account_id) %>%
  summarise(final_balance = last(balance))

# Per account, get the top 3 (if repeated over 20 times) reoccured amounts of type "credit" which so can be seen as regular income
# problem here is, we don't know the intervall, could be weekly or monthly, and regular incomes can also vary, which isn't covered here.
df_trans_join_ready2 = df_trans_prep %>% 
  filter(type=="credit") %>% 
  select(account_id, amount) %>% 
  group_by(account_id, amount) %>% 
  summarize(occurence_income=n()) %>% 
  top_n(3, occurence_income) %>% 
  filter(occurence_income > 20) %>% group_by(account_id) %>% summarise(amount = sum(amount))

# join the edited, grouped df_trans to the df
df_credit_check <- df_credit_check %>%
  left_join(df_trans_join_ready, by = "account_id")

df_credit_check<- df_credit_check %>%
  left_join(df_trans_join_ready2, by="account_id") %>%
  rename(avg_income = amount)

rm(df_trans_join_ready)
rm(df_trans_join_ready2)

```

```{r analysing generated table}
# analysing df_credit_check for criterias 
# tried with min(avg_income) + min(final_balance ) AND  mean(avg_income), mean(final_balance)
df_credit_check %>% 
  filter(!is.na(avg_income))%>% 
  group_by(card_type) %>% 
  summarise(min(avg_income), mean(final_balance))
```

Anhand der Tabelle und der vorherigen generellen Datenanalyse können nun Kriterien für das erfüllen oder nicht erfüllen der Bedingungen für einen Kartentyp aufgestellt und angewendet werden.

Criterias:

- cannot have loan status with "nok"
- if there is an avg income:
  - must be over 1k for junior (seems like with given junior cards the income is not extremely relevant)
  - must be over 8k for classic  (based on average income of districts, we decided if you earn around average it should be alright to get a standard card)
  - must be over 13k for gold (above average income)
- if there is no avg income:
  - balance must be over 60k for junior or classic
  - balance must be over 80k for gold
- if appropriate for gold or classic and under 25
  - give junior card
  
```{r applying criterias}
# check if there is a loan with status nok
df_credit_check <- df_credit_check %>%
  mutate(credit_check = if_else(
    !grepl("nok",loan_status),
    'unknown',
    'failed'
  ))

# check if suitable for junior while having avg_income
df_credit_check <- df_credit_check%>%
  mutate(credit_check = if_else(
    avg_income > 1000.0  & credit_check == "unknown" & age < 25,
    'junior', credit_check
  ))

# check if suitable for gold while having avg_income
df_credit_check <- df_credit_check%>%
  mutate(credit_check = if_else(
    avg_income > 13000.0  & credit_check == "unknown",
    'gold', credit_check
  ))

# check if suitable for classic while having avg_income
df_credit_check <- df_credit_check%>%
  mutate(credit_check = if_else(
    avg_income > 8000.0 & credit_check == "unknown",
    'classic',
    credit_check
  ))

# set to failed if none of the above fitted and has avg_income
df_credit_check <- df_credit_check %>%
  mutate(credit_check = if_else(
    !is.na(avg_income) & credit_check == "unknown",
    'failed',
    credit_check
  ))



df_credit_check <- df_credit_check %>%
  mutate(credit_check = if_else(
    is.na(avg_income) & credit_check == "unknown" & age < 25 & final_balance > 60000.0,
    'junior',
    credit_check
  ))

df_credit_check <- df_credit_check %>%
  mutate(credit_check = if_else(
    is.na(avg_income) & credit_check == "unknown" & final_balance > 80000.0,
    'gold',
    credit_check
  ))


df_credit_check <- df_credit_check %>%
  mutate(credit_check = if_else(
    is.na(avg_income) & credit_check == "unknown" & final_balance > 60000.0,
    'classic',
    credit_check
  ))


df_credit_check <- df_credit_check %>%
  mutate(credit_check = if_else(
    is.na(avg_income) & is.na(credit_check) & age < 25 & final_balance > 60000.0,
    'junior',
    credit_check
  ))


df_credit_check <- df_credit_check %>%
  mutate(credit_check = if_else(
    is.na(avg_income) & is.na(credit_check)  & final_balance > 80000.0,
    'gold',
    credit_check
  ))


df_credit_check <- df_credit_check %>%
  mutate(credit_check = if_else(
    is.na(avg_income) & is.na(credit_check)  & final_balance > 60000.0,
    'classic',
    credit_check
  ))

df_credit_check <- df_credit_check %>% relocate(credit_check, .after = card_type)
```

### Analyzing Credit Check Results

Der Credit Check gibt uns ein erstes engineertes Feature und ein Ergebnis, mit welchem gearbeitet werden kann. Er zeigt uns jedoch auch, das wir uns nicht rein auf eine relativ unsichere Berechnung mit vielen Annahmen festlegen sollten, und anhand der Transaktionstabelle genauere Features erstellen müssen.

#### Card type per loan status

Die Grafik zeigt, dass die Kunden mit "ok" Loan Stati eher eine Kreditkarte haben, als Kunden mit einem schlechten Loan Status. Die Bank achtet vermutlich bei der Herausagbe der Kreditkarte auch darauf, ob es beim Kunden schon mal Zahlungsprobleme gab, und entzieht diese möglicherweise deswegen auch wieder.

```{r getting ready to plot results}
# first steps with plots, showing the amount of card types per loan status
df_credit_check$card_type <- factor(df_credit_check$card_type, c("gold", "classic", "junior"))
df_credit_check$loan_status <- factor(df_credit_check$loan_status, c("finished_ok", "running_ok", "running_nok", "finished_nok"))

df_credit_check %>% filter(!is.na(loan_status)) %>% ggplot(mapping = aes(x = loan_status, fill= card_type, na.rm = TRUE)) +
  geom_bar(position = "fill") + 
  labs(title = "Card type per loan status", x = "Loan status", y = "# of Card Holders" , fill = "Card Type")
```

**Schlussfolgerungen**:

- Hat ein Bankkunde ein Darlehen mit "ok"-Stati, nutzt er auch eher eine Kreditkarte.

#### Scatter Plot of final balance and age, color coded by card types

Hier wird klar erkennbar, dass Junior-Karten bis zum 25. Lebensjahr ausgegeben werden. Für die Gold Kreditkarte scheint zwar generell kein höheres minimales Vermögen festgelegt zu sein. Dennoch geht eine Gold Kreditkarte in fast allen Fällen mit einem überdurchschnittlichen Vermögen einher. Erstaunlicherweise ist die Vermögensverteilung über alle Altersklassen hinweg ungefähr gleich, und das Vermögen nicht wie wir angenommen hätten, mit zunehmendem Alter zu.

```{r scatterplotting results}
df_credit_check %>% filter(!is.na(card_type))  %>% ggplot(mapping = aes(x = age, y = final_balance, color= card_type, na.rm = TRUE)) +
  geom_point() +
  stat_ellipse() + 
  labs(title = "Age vs current balance", subtitle = "grouped by type of Credit Card",x = "Age", y = "current balance in thousand" , color = "Card Type") +   scale_y_continuous(labels = label_number(suffix = " Kč", scale = 1e-3))
```

**Schlussfolgerungen:**

- Junior-Kreditkarten kann ein Bankkunde bis zum 25. Altersjahr besitzen
- Die Classic-Kreditkarten ist am meisten vertreten 
- Ist sein Vermögen höher, besitzt ein Kunde eher eine Gold-Kreditkarte
- Das Vermögen der Kreditkartenbesitzer nimmt mit zunehmendem Alter nicht zu

#### Income vs balance, color coded by card type

Es wird klar erkennbar, dass der größte Teil der Kunden ohne Kreditkarte (NA) in der unteren, linken Ellipse zu liegen kommen. Das ist ein Hinweis darauf, dass höheres Einkommen und Vermögen, im direkten Zusammenhang mit einer Kreditkarte, und später einer Kreditkarte höherer Stufe (Gold) steht. Kunden ohne Kreditkarte in den Kreisen von Classic und Gold könnten potenzielle Kunden sein. Je höher das Vermögen und Einkommen, desto eher ist ein Kunde für die Gold Kreditkarte geeignet.

Aktuell überschneiden sich Classic und Gold sehr stark. Würde man die Standards für Gold höher ansetzen, könnte man womöglich eine klarere Kundensegmentierung erhalten.

```{r further plots}
df_credit_check %>% filter(!is.na(avg_income))  %>% ggplot(mapping = aes(x = avg_income, y = final_balance, color= card_type, na.rm = TRUE)) +
  geom_point(alpha = 0.6)+
  stat_ellipse()+ 
  labs(title = "Scatter of current balance vs avg monthly income", subtitle = "grouped by type of Credit Card",x = "average monthly income in thousand", y = "current balance in thousand" , color = "Card Type") +   
  scale_y_continuous(labels = label_number(suffix = " Kč", scale = 1e-3)) +
  scale_x_continuous(labels = label_number(suffix = " Kč", scale = 1e-3))
```

**Schlussfolgerungen:**

- Höheres Vermögen und Einkommen stehen in direktem Zusammenhang mit dem Besitz einer Kreditkarte, und beeinflussen ab einer bestimmten Stufe auch den Typ (Classic, Gold)

#### Age variation per Card type

Dieser Plot zeigt die Altersunterschiede im Bezug auf die Kreditkarten. Auch hier sieht man, dass die Junior Karte bis auf einen Ausreisser auf 25 Jahre begrenzt zu sein scheint. Die Altersverteilung bei Classic und Gold sind ziemlich ähnlich, wobei Classic, wie man am Whisker erkennen kann, einzelne ältere Personen enthält.

```{r further plots-2}
df_credit_check %>% filter(!is.na(card_type)) %>% ggplot(mapping=aes(X=card_type, y=age, color = card_type)) +
  geom_boxplot() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
    labs(title = "Age variation per Card type", y = "Age" , color = "Card Type")
```

**Schlussfolgerungen:**

- Junior-Kreditkarten sind, wie der Name bereits erkennen lässt, für junge Kunden bis 25.
- Classic Kreditkarten decken mit 25-80 den höchsten Altersbereich ab.
- 50% der Besitzer einer Gold Kreditkarte sind zwischen 33 und 55 Jahren alt.

#### Monthly income variation by loan status

Dieser Plot zeigt das im Credit Check berechnete, regelmässige Einkommen nach Loan Status.
Es scheint auch hier plausibel, dass die Kunden mit Loans in einem "ok"-Status im Durchschnitt ein höheres Einkommen haben, als die im "nok"-Status.
Dabei müssen wir bedenken, dass wir nicht wissen, wann und wie oft dieser Loan Status gesetzt oder aktualisiert wird.

```{r further plots-3}
df_credit_check %>% filter(!is.na(loan_status)) %>% ggplot(mapping=aes(X=loan_status, y=avg_income, color = loan_status)) +
  geom_boxplot() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
    labs(title = "Monthly income variation per loan status", y = "Monthly income in thounsand" , color = "Loan Status") + 
  scale_y_continuous(labels = label_number(suffix = " Kč", scale = 1e-3))
```

**Schlussfolgerungen:**

- Bei Kunden mit höherem monatlichen Einkommen läuft die Bank insgesamt weniger Gefahr, Zahlungsausfälle bei Darlehen zu erhalten.

#### Last known balance distribution per loan status

Es scheint auch hier vernünftig, dass die Kunden mit Loans im "ok"-Status im Durchschnitt einen höheren Saldo haben, als die mit Loans im "nok"-Status.
Dabei ist auch hier zu beachten, dass wir nicht wissen, wann und wie oft dieser Status gesetzt oder aktualisiert wird.

```{r further plots-4}
df_credit_check %>% filter(!is.na(loan_status)) %>% ggplot(mapping=aes(X=loan_status, y=final_balance, color = loan_status)) +
  geom_boxplot() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
    labs(title = "Last known balance distribution per loan status", y = "Current balance in thounsand" , color = "Loan Status") + 
  scale_y_continuous(labels = label_number(suffix = " Kč", scale = 1e-3))
```

**Schlussfolgerungen:**

- Bei Kunden mit höherem Saldo auf dem Konto ist die Gefahr eines Zahlungsausfalls bei Darlehen für die Bank geringer.

## Approximating weekly account balances

Im nächsten Schritt unserer Analyse möchten wir die Datengrundlage über die detaillierte Vermögensentwicklung eines jeden Kunden schaffen.Diese Informationen lassen sich alle aus dem Datensatz df_trans_prep, der alle Transaktionen enthält, ableiten. Ziel ist es, das Vermögen aller Kunden in jeder Woche über den Zeitraum der Daten hinweg, zu erhalten.

### Calculating weekly account balance using SQL Script

Wir haben die Berechnung des wöchentlichen Kontostandes mittels SQL gemacht, um etwas Zeit zu sparen. 
Die Resultate können mit folgenden Schritten reproduziert werden:

- Host local postgres db using docker: `docker run --name cross-selling-postgres -p 5555:5432 -e POSTGRES_PASSWORD=secret -d postgres`
- Connect to database using `postgres` / `secret` credentials
- Load csv exported below into database
- Use SQL script in `trans_to_weekly_balance` folder to approximate weekly balances based on transactions
- Export query result from database as df_weekly_balance.csv
- Import query result as new R df


```{r export trans df for external use}
# export to import into postgres db
write.csv(df_trans_prep, "trans_to_weekly_balance/df_trans_prep.csv", row.names = FALSE)
```

Folgende SQL Query bricht alle Transaktionen gruppiert nach Account und Woche herunter, und berechnet dann aus den Transaktionen in dem Zeitraum den durchschnittlichen Kontostand:
```SQL
SELECT account_id                      AS account_id,
       date_trunc('week', t1.date)     AS week,
       MIN(balance)                    AS min,
       ROUND(AVG(balance)::numeric, 2) as avg,
       MAX(balance)                    AS max,
       COUNT(*)                        AS trans_count
FROM (
         SELECT account_id AS account_id,
                date       AS date,
                balance    AS balance,
                RANK() OVER (
                    PARTITION BY account_id, date_trunc('week', date)
                    ORDER BY account_id, date DESC
                    )      AS rank
         FROM df_trans_prep
         ORDER BY account_id, date DESC
     ) AS t1
WHERE t1.rank = 1
GROUP BY t1.account_id, date_trunc('week', t1.date)
ORDER BY t1.account_id, date_trunc('week', t1.date);
```

Resultate importieren:
```{r import-results}
# import postgres db query result
df_weekly_balance <- read.table("trans_to_weekly_balance/df_weekly_balance.csv",
                         header = FALSE,
                         sep = ",")
```

### Preprocessing df_weekly_balance

Aktuell gibt es überall da, wo sich über eine oder mehrere Wochen auf dem Konto keine Transaktion ereignet hat, eine Lücke in den Daten. Um den Verlauf des Kontostandes Lückenlos visualisieren zu können, ergänzen wir in diesen Fällen die Daten um den Kontostand der jeweils vorherigen Woche.

```{r}
# mutate df
df_weekly_balance_prep <- df_weekly_balance %>%
  rename(account_id = V1, week = V2, min = V3, balance_avg = V4, max = V5, trans_count = V6) %>%
  arrange(account_id, week) %>%
  mutate(week = substr(week, 1, 10)) %>%
  mutate(week = as.Date(week, "%Y-%m-%d"))

# extend df with the calculated balance each week, even when no transactions took place
df_weekly_balance_prep <- df_weekly_balance_prep %>%
  complete(account_id, week = seq.Date(min(week), max(week), by="week")) %>% # add new rows for all missing weeks on each account
  fill(min, balance_avg, max, trans_count) %>% # fill NA with values of previous row
  filter(!is.na(balance_avg)) # remove entries created for weeks where bank account didn't exist

df_weekly_balance_prep %>% head(50)
```

### Visualizing the balance change for an account

Wir prüfen, ob die Berechnung von df_weekly_balance_prep erfolgreich war, indem wir den Saldoverlauf eines definierten Kontos plotten. Auf diesen Daten werden wir spätere Analysen basieren.

```{r plotting with selected account}
# Filter df
selected_account_id <- 6226

df_weekly_balance_prep_filtered <- df_weekly_balance_prep %>%
  filter(account_id %in% c(selected_account_id)) %>%
  filter(week > "1994-01-01" & week < "1994-12-31") %>%
  arrange(week)

df_weekly_balance_prep_filtered2 <- df_weekly_balance_prep %>%
  filter(account_id %in% c(selected_account_id)) %>%
  filter(week > "1994-01-01" & week < "1994-03-01") %>%
  arrange(week)
  
df_weekly_balance_prep_filtered3 <- df_weekly_balance_prep %>%
  filter(account_id %in% c(selected_account_id)) %>%
  arrange(week)

# Plot
ggplot(df_weekly_balance_prep_filtered, aes(x = week, y = balance_avg)) +
  geom_step() +
  expand_limits(y = 0) + 
  labs(title = "Weekly balance January - December 1994", subtitle = "of previously selected single Account",x = "Timescale", y = "Balance in thousand") +   
  scale_y_continuous(labels = label_number(suffix = " Kč", scale = 1e-3))

ggplot(df_weekly_balance_prep_filtered2, aes(x = week, y = balance_avg)) +
  geom_step() +
  expand_limits(y = 0)+
  labs(title = "Weekly balance January and February 1994", subtitle = "of previously selected single Account",x = "Timescale", y = "Balance in thousand") +   
  scale_y_continuous(labels = label_number(suffix = " Kč", scale = 1e-3))

ggplot(df_weekly_balance_prep_filtered3, aes(x = week, y = balance_avg)) +
  geom_step() +
  expand_limits(y = 0)+
  labs(title = "Weekly balance over account existence", subtitle = "of previously selected single Account",x = "Timescale", y = "Balance in thousand") +   
  scale_y_continuous(labels = label_number(suffix = " Kč", scale = 1e-3))

# Clean up
rm(df_weekly_balance_prep_filtered)
rm(df_weekly_balance_prep_filtered2)
rm(df_weekly_balance_prep_filtered3)
```

## Putting together the Customer Analytics Report

Wir joinen alle bisher gesammelten und engineerten Features zu den Bankkunden aus den verschiedenen Datensätzen zu einem grossen Customer Analytics Report zusammen, den wir für alle weiteren Analysen und Cross-Selling vorhersagen nutzen können.

### Joining our dataframes
#### Preparing df_order_prep for joining to df_car
```{r}
df_order_prep_f <- df_order_prep %>% 
  mutate(household = if_else(
    payment_category == "household",
    TRUE,
    FALSE
  )) %>%
  mutate(leasing = if_else(
    payment_category == "leasing",
    TRUE,
    FALSE
  )) %>%
   mutate(loan = if_else(
    payment_category == "loan",
    TRUE,
    FALSE
  )) %>%
   mutate(insurance = if_else(
    payment_category == "insurance",
    TRUE,
    FALSE
  )) %>%
  mutate(missing = if_else(
    payment_category == "missing",
    TRUE,
    FALSE
  ))

df_order_prep_f <- df_order_prep_f %>%
  group_by(account_id) %>%
  summarise(
    sum_amount = sum(amount),
    household = max(household),
    leasing = max(leasing),
    loan = max(loan),
    insurance = max(insurance),
    uncategorized = max(missing)
  )

# Add Prefix for overview when joining
names(df_order_prep_f) <- paste0("order.", names(df_order_prep_f))
```

#### Creating df_car, joining given customer information
```{r}
df_disp_prep_f <- df_disp_prep
names(df_disp_prep_f) <- paste0("disp.", names(df_disp_prep_f))

df_loan_prep_f <- df_loan_prep %>% select(account_id, date, amount, duration, monthly_rate, status)
names(df_loan_prep_f) <- paste0("loan.", names(df_loan_prep_f))

df_card_prep_f <- df_card_prep %>% select(disp_id, type, issued)
names(df_card_prep_f) <- paste0("card.", names(df_card_prep_f))

df_client_prep_f <- df_client_prep %>% select(client_id, district_id_client, gender, dob, age)
names(df_client_prep_f) <- paste0("client.", names(df_client_prep_f))

df_district_prep_f <- df_district_prep %>% select(district_id, avg_salary, urban_ratio, enterpren_rate)
names(df_district_prep_f) <- paste0("district.", names(df_district_prep_f))

df_account_prep_f <- df_account_prep
names(df_account_prep_f) <- paste0("account.", names(df_account_prep_f))

df_car <- df_disp_prep_f %>%
  filter(disp.type == "owner") %>%
  inner_join(df_account_prep_f, by = c("disp.account_id" = "account.account_id")) %>%
  inner_join(df_client_prep_f, by = c("disp.client_id" = "client.client_id")) %>%
  left_join(df_loan_prep_f, by = c("disp.account_id" = "loan.account_id")) %>%
  mutate(loan.has_loan = if_else(is.na(loan.duration), FALSE, TRUE)) %>%
  left_join(df_card_prep_f, by = c("disp.disp_id" = "card.disp_id")) %>%
  mutate(card.has_card = if_else(is.na(card.issued), FALSE, TRUE)) %>%
  left_join(df_order_prep_f, by = c("disp.account_id" = "order.account_id")) %>%
  mutate(order.has_orders = if_else(is.na(order.sum_amount), FALSE, TRUE)) %>%
  inner_join(df_district_prep_f, by = c("client.district_id_client" = "district.district_id"))

df_car %>% sample_n(size=10)
```

```{r car-temp-df-cleanup}
rm(df_disp_prep_f)
rm(df_account_prep_f)
rm(df_client_prep_f)
rm(df_loan_prep_f)
rm(df_card_prep_f)
rm(df_order_prep_f)
rm(df_district_prep_f)
```

### Feature Engineering for Cross-Selling on Credit Cards and Loans

Basierend auf den Informationen, die wir nun durch das joinen der unterschiedlichen Datensätze in `df_car` zu den Bankkunden gewonnen haben, entwickeln wir zusätzliche Features. 

Nach unserem bisherigen Verständnis der Daten gibt es einige Faktoren, die die Hinweise geben können, ob ein Kunde mit seinem Geld umzugehen weiss. Diese können uns behilflich sein, wenn wir herausfinden wollen, welche Kunden für die Bankprodukte Kreditkarte und Loan geeignet sind. Wir erhoffen uns, dass sich dadurch Muster erkennbar machen, die wir für das Cross-Selling nutzen können. Zum Beispiel, welche Eigenschaften Kunden mit von Kunden ohne Kreditkarte unterscheidet, was die Abstufungen junior, classic und gold beeinflusst, und welche Ausgangslage für den Bezug einer Kreditkarte optimal ist.

#### Engineering Features around Credit Card issuance
Wir verwenden unseren neu berechneten Datensatz df_weekly_balance, um drei neue Features für jeden Kunden rund um den Zeitpunkt der Herausgabe der Kreditkarte zu entwickeln.

Die Features sind die folgenden:
- eng.balance_dev_1y_before_card
  - Dieses Feature zeigt, wie sich das Vermögen des Kunden in absoluten Zahlen im Jahr bevor der herausgabe der Kreditkarte entwickelt hat.
  - Hat ein Kunde keine Kreditkarte, beziehen wir uns für die Berechnung auf das letzte Jahr in den Daten.
- eng.balance_at_card_issuance
  - Dieses Feature ist der absolute Saldo des Kontos, als der Kunde die Kreditkarte erhalten hat.
  - Hat ein Kunde keine Kreditkarte, beziehen wir uns auf den Saldo zum letzten Zeitpunkt in den Daten.
- eng.balance_dev_after_card
  - Dieses Feature zeigt die absolute Vergmögensentwicklung im Jahr nach der Kartenherausgabe.
  - Hat ein Kunde keine Kreditkarte, bekommt es den Wert 0.

```{r}
# we need to extract last balance_avg for every month and add 15 days, so the balance_dev calculation of the following month 
# considers the value of the last month as the first balance when grouping by month and getting min(week)
df_balance_development_addition <- df_weekly_balance_prep %>%
  mutate(year = format(week, "%Y"), month = format(week, "%m")) %>%
  group_by(account_id, year, month) %>%
  filter(week == max(week)) %>%
  mutate(year = format(week + 15, "%Y"), month = format(week + 15, "%m"))

# we add a column year and month for grouping later
df_balance_development_temp <- df_weekly_balance_prep %>%
  mutate(year = format(week, "%Y"), month = format(week, "%m"))

# bind both dataframes
df_balance_development_comb <- bind_rows(df_balance_development_addition, df_balance_development_temp) %>%
  arrange(account_id, year, month, week)

df_balance_development <- df_balance_development_comb %>%
  group_by(account_id, year, month) %>%
  summarize(
    start_balance = balance_avg[week == min(week)],
    end_balance = balance_avg[week == max(week)],
  ) %>%
  mutate(balance_dev = end_balance - start_balance) %>%
  ungroup()

rm(df_balance_development_addition, df_balance_development_temp, df_balance_development_comb)

df_balance_development %>% head(50)
```

Helper functions for creating df_balance_development:
```{r functions}
calc_balance_dev_in_range <- function(start, end, id) {
  df_func <- df_balance_development %>% 
    filter(account_id == id) %>%
    mutate(date = as.Date(paste(year,month,"01",sep = "-"), "%Y-%m-%d")) %>%
    filter(date >= start, date <= end) %>%
    summarise(total_dev = sum(balance_dev))
  result = df_func$total_dev
  rm(df_func)
  return(result)
}

calc_balance_at_date <- function(date, id) {
  if(is.na(date)) {
    # duplicate of calc_final_balance()
    df_func <- df_balance_development %>%
      filter(account_id == id, year == "1999", month == "01")
    
    result = df_func$end_balance
    rm(df_func)
    return(result)
  } else {
    date_year = format(date, "%Y")
    date_month = format(date, "%m")
    df_func <- df_balance_development %>% 
      filter(account_id == id, year == date_year, month == date_month) %>%
      summarise(balance = start_balance)
    
    result = df_func$balance
    rm(df_func)
    return(result)
  }
}

calc_final_balance <- function(id) {
  df_func <- df_balance_development %>%
    filter(account_id == id, year == "1999", month == "01")
  result = df_func$end_balance
  rm(df_func)
  return(result)
}
```

Extending df_car with calculated balance development information:
```{r main code feature engineering}
last_transaction_date <- as.Date("1998-12-31", "%Y-%m-%d")

df_car_ext <- df_car %>%
  rowwise() %>%
  mutate(
    eng.balance_dev_1y_before_card = if_else(
      card.has_card == TRUE,
      calc_balance_dev_in_range(card.issued %m-% months(13), card.issued %m-% months(1), disp.account_id),
      calc_balance_dev_in_range(last_transaction_date %m-% months(13), last_transaction_date %m-% months(1), disp.account_id)
    ),
    eng.balance_at_card_issuance = calc_balance_at_date(card.issued, disp.account_id),
    eng.balance_dev_after_card = if_else(
      card.has_card == TRUE,
      calc_balance_dev_in_range(card.issued %m-% months(1), card.issued %m+% months(11), disp.account_id),
      0
    )
  )
```

Um ein einen ersten Eindruck über die Beschaffenheit unserer Features zu erhalten, schauen wir uns ihre Verteilung an.

Bei unserem Feature "eng.balance_dev_1y_before_card" zeigt sich eine Normalverteilung.

```{r control plots}
ggplot(df_car_ext, aes(x = eng.balance_dev_1y_before_card)) +
  geom_density() + labs(title = "Balance developement 1y before card", x = "Balance dev. 1y befor card issuance", y = "Density") +
  scale_x_continuous(labels = label_number(suffix = " Kč", scale = 1e-0))
```

Bei unserem Feature "eng.balance_at_card_issuance" zeigt sich eine rechtsschiefe Verteilung. Dies trägt natürlich Rechnung dafür, dass es weniger Kunden mit grossem Vermögen gibt.

```{r control plots-2}
ggplot(df_car_ext, aes(x = eng.balance_at_card_issuance)) +
  geom_density() + 
  labs(title = "Balance at card issuance", x = "Balance at card issuance", y = "Density")+
  scale_x_continuous(labels = label_number(suffix = " Kč", scale = 1e-0))
```

Das Feature "eng.balance_dev_after_card" zeigt im Zentrum eine steile Normalverteilung. 

Achtung: Hier Berücksichtigen wir nur Kunden mit einem Wert != 0, da das Resultat ansonsten von den Kunden ohne Kreditkarten beeinflusst wird.

```{r control plots-3}
ggplot(df_car_ext %>% filter(eng.balance_dev_after_card != 0), aes(x = eng.balance_dev_after_card)) +
  geom_density() +
  labs(title = "Balance developement after card issuance", x = "Balance developement after card issuance", y = "Density")+
  scale_x_continuous(labels = label_number(suffix = " Kč", scale = 1e-0))
```

#### Average transactions per month for each account

Um die Aktivität und Nutzung der Kunden auswerten zu können, berechnen wir, wie viele Transaktionen im Schnitt pro Account monatlich durchgeführt werden.

```{r further feature engineering}
# calculate mean transactions per month for each account
df_mean_trans_count_per_month <- df_weekly_balance_prep %>%
  mutate(year = format(week, "%Y"), month = format(week, "%m")) %>%
  group_by(account_id, year, month) %>%
  summarize(trans_count_month = sum(trans_count)) %>%
  ungroup() %>%
  group_by(account_id) %>%
  summarize(mean_trans_count_per_month = round(mean(trans_count_month), digits = 2)) %>%
  ungroup()
names(df_mean_trans_count_per_month) <- paste0("eng.", names(df_mean_trans_count_per_month)) # add eng. prefix before join

# join to df_car_ext
df_car_ext <- df_car_ext %>%
  left_join(df_mean_trans_count_per_month, by = c("disp.account_id" = "eng.account_id"))

# check distribution
ggplot(df_mean_trans_count_per_month, aes(x = eng.mean_trans_count_per_month)) +
  geom_density() +
  xlim(0, NA)+
  labs(title = "Transaction count per month", x = "Mean of transactions per month", y = "density")

rm(df_mean_trans_count_per_month)
```

#### Average balance development per month

Um die Tendenz der Vermögensentwicklung pro Kunde messbar zu machen, berechnen wir aus den Daten seit der Erstellung des Kontos, um welchen prozentualen Wert sich das Vermögen durchschnittlich im Monat verändert hat.

```{r further feature engineering-2}
# median balance development in percent % for each account
# note: the mean is not meaningful here, as it gets distorted by outliers (e.g. on huge one-time transactions to/from account)
df_median_relative_balance_dev <- df_balance_development %>%
  mutate(relative_balance_dev_in_perc = round(balance_dev * 100 / start_balance, digits = 2)) %>%
  group_by(account_id) %>%
  summarize(median_relative_balance_dev_in_perc = median(relative_balance_dev_in_perc))
names(df_median_relative_balance_dev) <- paste0("eng.", names(df_median_relative_balance_dev))

ggplot(df_median_relative_balance_dev, aes(x = eng.median_relative_balance_dev_in_perc)) +
  geom_density() +
  scale_x_continuous(labels = label_number(suffix = "%")) +
  xlab("Median of relative balance development per account in percent") +
  ylab("Density")

df_car_ext <- df_car_ext %>%
  left_join(df_median_relative_balance_dev, by = c("disp.account_id" = "eng.account_id"))

rm(df_median_relative_balance_dev)
```

### Correction of variable types

```{r}
df_car_ext <- df_car_ext %>%
  mutate(
    card.type = as.factor(card.type),
    client.gender = as.factor(client.gender)
  )
```

## Plots with Customer Analaytics Record

Wir nutzen den aktuellen Customer Analytics Record inkl. der neu engineerten Features, um mehr Informationen zu ihrer Beschaffenheit und Aussagekräftigkeit im Bereich des Cross-Selling zu erhalten.

### Data Preparation
```{r}
bal_segmentation <- function(balance) {
  if(balance < 0) {
  result = "negative"} 
  else if(balance > 0 & balance < 10000) {
  result = "10 k"} 
  else if(balance > 10000 & balance < 20000) {
  result = "20 k"}
  else if(balance > 20000 & balance < 30000) {
  result = "30 k"}
  else if(balance > 30000 & balance < 40000) {
  result = "40 k"}
  else if(balance > 40000 & balance < 50000) {
  result = "50 k"}
  else if(balance > 50000 & balance < 60000) {
  result = "60 k"}
  else if(balance > 60000 & balance < 70000) {
  result = "70 k"}
  else if(balance > 70000 & balance < 80000) {
  result = "80 k"}
  else if(balance > 80000 & balance < 90000) {
  result = "90 k"}
  else if(balance > 90000 & balance < 100000) {
  result = "100 k"}
  else if(balance > 100000 & balance < 110000) {
  result = "110 k"}
  else if(balance > 110000 & balance < 120000) {
  result = "120 k"}
  else if(balance > 120000 & balance < 130000) {
  result = "130 k"}
  else {
  result = "140k +"}
  return(result)
}

dev_segmentation <- function(dev) {
  if(dev < 0) {
  result = "negative"} 
  else if(dev > 0 & dev < 10000) {
  result = "10 k"} 
  else if(dev > 10000 & dev < 20000) {
  result = "20 k"}
  else if(dev > 20000 & dev < 30000) {
  result = "30 k"}
  else if(dev > 30000 & dev < 40000) {
  result = "40 k"}
  else if(dev > 40000 & dev < 50000) {
  result = "50 k"}
  else if(dev > 50000 & dev < 60000) {
  result = "60 k"}
  else if(dev > 60000 & dev < 70000) {
  result = "70 k"}
  else if(dev > 70000 & dev < 80000) {
  result = "80 k"}
  else if(dev > 80000 & dev < 90000) {
  result = "90 k"}
  else if(dev > 90000 & dev < 100000) {
  result = "100 k"}
  else if(dev > 100000 & dev < 110000) {
  result = "110 k"}
  else if(dev > 110000 & dev < 120000) {
  result = "120 k"}
  else if(dev > 120000 & dev < 130000) {
  result = "130 k"}
  else {
  result = "140k+"}
  return(result)
}

df_car_segments <- df_car_ext %>%
  mutate(
    dev_factor = if_else(card.has_card == TRUE, round((eng.balance_dev_after_card / eng.balance_at_card_issuance) * 100, digits = 2), 0),
    bal_segment = bal_segmentation(eng.balance_at_card_issuance),
    dev_segment = if_else(
      card.has_card == TRUE,
      dev_segmentation(eng.balance_dev_after_card),
      "none"
    )
  )

df_car_segments$dev_segment <- factor(df_car_segments$dev_segment, c("10 k", "20 k", "30 k", "40 k", "50 k", "60 k", "70 k", "80 k", "90 k", "100 k", "110 k", "120 k", "130 k", "140 k+"))
df_car_segments$bal_segment <- factor(df_car_segments$bal_segment, c("10 k", "20 k", "30 k", "40 k", "50 k", "60 k", "70 k", "80 k", "90 k", "100 k", "110 k", "120 k", "130 k", "140 k+"))
```
### Plots

#### Balance at card issuance variation per card type

Das arithmetische Mittel des Saldos zum Zeitpunkt der Ausstellung der Kreditkarte beläuft sich für Classic- und Junior Karten auf ungefähr 50'000 Kč, während es bei den Gold-Karten 70'000 Kč sind. Bei Classic Karten sind viele Ausreisser nach oben zu erkennen. Hier verbirgt sich für die Bank womöglich Upselling-Potential für die Gold Kreditkarte.

```{r}
df_car_ext %>% filter(card.has_card == TRUE) %>% ggplot(mapping=aes(x = card.type, y = eng.balance_at_card_issuance, color = card.type)) +
  geom_boxplot() + 
  theme(axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  labs(title = "Balance at card issuance variation per card type", y = "Current balance in thounsand" , color = "Card Type") + 
  scale_y_continuous(labels = label_number(suffix = " Kč", scale = 1e-3))
```

**Schlussfolgerungen:**

- Bei der Issuance hatten Besitzer von Junior- und Classic Kreditkarten im Schnitt einen Saldo von 50'000 Kč.
- Bei der Issuance hatten Besitzer von Gold Kreditkarten im Schnitt einen Saldo von 70'000 Kč.
- Was den Saldo angeht, birgt ein Upselling von  Classic- auf Goldkreditkarten womöglich viel Potenzial.

#### Boxplots around features and customer balance segments

Wir möchten nun mit analytischen Plots feststellen können, ob sich gewisse Attribute auf die Vermögentsentwicklung nach Erhalt der Karte auswirken. 
Dazu ergänzen wir die Daten mit dem kategorischen Wert für die Art der Vermögensentwicklung, und verwenden dann diese um sie in Plots zu vergleichen.

```{r}
# devide df_car_segments in developement groups by adding new attribute "categ"
test_df_car_segments <- df_car_segments %>% mutate(categ = if_else(dev_factor <= 0.000, "bad", "good")) %>% filter(card.has_card == TRUE)
test_df_car_segments <- test_df_car_segments %>% mutate(categ = if_else(dev_factor >= 10.000, "very good", categ))
test_df_car_segments <- test_df_car_segments %>% mutate(categ = if_else(dev_factor <= -10.000, "very bad", categ))
test_df_car_segments$loan.monthly_rate[is.na(test_df_car_segments$loan.monthly_rate)] <- 0

# adding average income method from credit check for analysis
df_trans_join_ready = df_trans_prep %>% 
  filter(type=="credit") %>% 
  select(account_id, amount) %>% 
  group_by(account_id, amount) %>% 
  summarize(occurence_income=n()) %>% 
  top_n(3, occurence_income) %>% 
  filter(occurence_income > 20) %>% group_by(account_id) %>% summarise(cc.reg_income = sum(amount))

test_df_car_segments<- test_df_car_segments %>%
  left_join(df_trans_join_ready, by = c("disp.account_id" = "account_id"))

rm(df_trans_join_ready)

test_df_car_segments %>% ggplot(mapping = aes(x = client.age, color = categ)) +
  geom_density() +
  labs(title = "Age ", subtitle = "density per developement category", x = "Age", y = "density")

test_df_car_segments %>% ggplot(mapping = aes(x = eng.balance_at_card_issuance, color = categ)) +
  geom_density()+
  labs(title = "Balance ", subtitle = "density per developement category", x = "Balance", y = "density")+ 
  scale_x_continuous(labels = label_number(suffix = " Kč", scale = 1e-0))

test_df_car_segments %>% ggplot(mapping = aes(x = eng.balance_dev_1y_before_card, color = categ)) +
  geom_density()+
  labs(title = "Balance dev. before card ", subtitle = "density per developement category", x = "Balance dev. before card", y = "density")

test_df_car_segments %>% ggplot(mapping = aes(x = eng.mean_trans_count_per_month, color = categ)) +
  geom_density()+
  labs(title = "Mean transactions per month ", subtitle = "density per developement category", x = "Mean transactions per month", y = "density")

test_df_car_segments %>% ggplot(mapping = aes(x = loan.monthly_rate, color = categ)) +
  geom_density()+
  labs(title = "monthly loan rate ", subtitle = "density per developement category", x = "monthly loan rate", y = "density")

test_df_car_segments %>% ggplot(mapping = aes(x = order.sum_amount, color = categ)) +
  geom_density()+
  labs(title = "sum of regular orders ", subtitle = "density per developement category", x = "sum of regular orders", y = "density")

test_df_car_segments %>% ggplot(mapping = aes(x = district.urban_ratio, color = categ)) +
  geom_density()+
  labs(title = "urban ratio ", subtitle = "per developement category", x = "District urban ratio", y = "density")

test_df_car_segments %>% ggplot(mapping = aes(x = district.avg_salary, color = categ)) +
  geom_density()+
  labs(title = "average salary ", subtitle = "density per developement category", x = "average salary", y = "density")


test_df_car_segments %>% ggplot(mapping = aes(x = bal_segment,  fill = categ)) +
  geom_bar(position = "fill") +
  labs(title = "Balance segment", subtitle = "percentage per developement category", x = "Balance segment", color = "Developement category")


test_df_car_segments %>% ggplot(mapping = aes(x = dev_segment,  fill = categ)) +
  geom_bar(position = "fill") +
  labs(title = "Developement segment", subtitle = "percentage per developement category", x = "Developement segment", color = "Developement category")

test_df_car_segments %>% ggplot(mapping = aes(x = categ,y = eng.balance_at_card_issuance, fill =categ)) +
  geom_violin() +
  labs(title = "Balance at card issuance", subtitle = "per developement category", y = "Balance at card issuance", x = "Developement category")


test_df_car_segments %>% ggplot(mapping = aes(x = categ,y = cc.reg_income, fill =categ)) +
  geom_violin() +
  labs(title = "Regular income", subtitle = "per developement category", y = "Regular income", x = "Developement category")

test_df_car_segments %>% ggplot(mapping = aes(x = eng.balance_at_card_issuance, y = cc.reg_income, color =categ)) +
  geom_point() + stat_ellipse()+
  labs(title = "Balance vs. regular income", subtitle = "per developement category", y = "Regular income", x = "Balance at card issuance", color = "Developement category")+ 
  scale_x_continuous(labels = label_number(suffix = " Kč", scale = 1e-0))

rm(test_df_car_segments)
```

**Schlussfolgerungen:**

- 30 bis 35 Jährige haben eher schlechtere Developement Stati als die anderen Altersklassen
- Bei einer balance von 50k gibt es weniger sehr schlechte Vermögensveränderungen, bei allen anderen Vermögen kann keine starke Abweichung ekannt werden
- Die Vermögensveränderung vor Erhalt der Karte, die Anzahl Transaktionen/Monat, die monatlichen Darlehensraten, die Summe von Daueraufträgen, die Urbanität des Districts und das Durchschnittseinkommen des Districts, geben uns keine aussagekräftigen Hinweise auf die Entwicklung des Vermögens nach Kartenerhalt.
- Interessanterweise zeigen uns die Plots, dass je höher das Einkommen vor Erhalt der Kreditkarte war, desto eher tendieren die Kunden zu schlechten Vermögensentwicklungen nach Erhalt der Karte. Wir haben die Berechnungen nochmals geprüft und auch Stichproben durchgeführt. Manchmal hat ein Kunde nach dem geprüften Jahr nach Erhalt der Kreditkarte wieder ein besseren Verlauf, jedoch bestätigen die Stichproben die Erkentniss des Plots, was uns sehr erstaunt.
- Der letzte Scatter Plot relativiert die Aussage etwas, da die Ellipsen sehr nahe beieinander sind und die Observationen verteilt über die Grafik.

#### Vermögensveränderung nach Kartenerhalt

Wir möchten hier noch einmal das unerwartete Ergebnis der oberen Grafiken genauer prüfen, da wir die Hypothese verfolgen:

> Je höher das Vermögen bevor eine Kreditkarte ausgestellt wurde, desto kleiner die Chance, dass der Kunde sich verschuldet.

Dieser Plot zeigt die Vermögensentwicklung pro "Vermögenskategorie".

```{r}
df_car_segments %>% filter(card.has_card == TRUE, bal_segment != "negative") %>% ggplot(mapping = aes(x = bal_segment, y = eng.balance_dev_after_card)) +
  geom_boxplot() +
  labs(
    title = "Vermögensveränderung nach Kartenerhalt",
    subtitle = "anhand Vermögensklasse bei Anschaffung",
    y = "Vermögensentwicklung",
    x = "Vermögensgruppe" ,
    color = "Card Type"
  ) +
  scale_y_continuous(labels = label_number(suffix = " Kc"))
```

Dieser Plot zeigt die Density der Vermögensveränderung. Es ist somit erkennbar, dass sich das Vermögen der meisten Kunden um +-20k veränderte. Dieser Plot ist wichtig für das korrekte interpretieren der vorherigen Boxplots.

```{r}
df_car_segments %>% filter(card.has_card == TRUE) %>% ggplot(mapping = aes(x = eng.balance_dev_after_card, color = card.type)) +
  geom_density() +
  labs(
    title = "Density Vermögensveränderung",
    x = "Vermögensveränderung" ,
    color = "Card Type"
  )+
  scale_y_continuous(labels = label_number(scale = 1e+6))
```
Und hier nun ein Scatterplot der Vermögensveränderung vs. dem Kontostand bei Erhalt der Karte für eine detailiertere Analyse der einzelnden Observationen, welche die Boxplots ausmachen.

```{r}
df_car_segments %>% filter(dev_factor != 0) %>% ggplot(mapping = aes(x = dev_factor, y = eng.balance_at_card_issuance, color = card.type)) +
  geom_point() +
  labs(
    title = "Developement factor vs balance at issuance",
    y = "balance at issuance",
    x = "developement factor" ,
    color = "Card Type"
  ) +
  scale_y_continuous(labels = label_number(suffix = " Kc", scale = 1e-0)) +
  scale_x_continuous(labels = label_number(suffix = " %"))+ stat_ellipse()
```

**Schlussfolgerungen:**

 Es zeigt sich, das es eine Tendenz gibt, dass je höher die Vermögensklasse, desto schlechter die Vermögensentwicklung.
 Die Boxen sind jedoch relativ gross und haben auch teilweise lange whiskers, was die Streuung des Scatterplots im oberen Kapitel gut gezeigt hat.
 Schauen wir uns die positiven Vermögensveränderungsklassen an, so kann kein signifikanter Unterschied der Vermögen bei Kartenerhalt aufgezeigt werden.
 
Zu beachten ist immer, dass es deutlich weniger Kunden gibt mit grossem Vermögen, so verändert ein einzelner Kunde die Boxplots stärker als bei mittlerem Vermögen. Das ist gut erkennbar im Density Plot.

Der letzte Scatterplot bestätigt wiederum die erkannte Korrelation zwischen höherem Vermögen und schlechterer Vermögensentwicklung. Er zeigt jedoch auch nochmals, dass der Hauptteil der Kunden sich in der Kategrie der Vermögensetwicklung +-50% befinden.

# Cross-Selling Predictions

In diesem Teil nutzen wir unsere zuvor gesammelten Erkenntnisse und den Customer Analytics Report mit den zusätzlich engineerten Features, um spezifische Vorhersagen pro Kunde auf die Banking Produkte Darlehen und Kreditkarte zu machen. Daraus leiten wir anschliessend konkrete Cross-Selling und Up-Selling Vorschlöge für jeden Kunden der Bank ab.

## Customer Segmentation using K-Means Clustering

Wir prüfen, ob sich die Kunden nach ihren Eigenschaften mittels K-Means in Clustern so segmentieren lassen, dass wir klare Kundengruppen bestimmen können. Dieser Algorithmus fällt in die Kategorie des Unsupervised Learning, da wir dem Algorithmus keinen Zielwert vorgeben. Gelingt dies, können wir daraus möglicherweise basierend auf der Gruppe, in der sich ein Kunde befindet, Cross-Selling Vorschläge machen.

### Methode

Wir untersuchen die Möglichkeiten von Cross-Selling mittels Clustering.

Das Ziel:

- Statistisch relevant Features im CAR identifizieren
- Damit die Kunden so segmentieren, dass über ähnlichkeiten der Ausgangslage, aber Unterschiede in den Bankprodukten, bestimmten Kunden bestimmte Produte vorgeschlagen werden können.
  - Fallen beispielsweise Kunden in ein Segment, in dem typischerweise alle anderen eine "Gold" Kreditkarte besitzen, sollte dem Kunden diese vorgeschlagen werden.

Vorbereitung:

- Wir haben die Input Daten gejoint, und so eine Tabelle mit Informationen über 4500 Kunden, die Basis unseres Customer Analytics Records, erhalten.
- Anschliessend haben wir Feature Engineering betrieben, und so unter anderem berechnet, wie sich das Vermögen der Kunden mit Kreditkarte, im Jahr vor der Issuance entwickelt hat.
- Resultat ist eine Tabelle mit aktuell 30 Features zu jedem Kunden.

Clustering:

- Mittels K-Means Algorithmus und ausgewählten Kundendaten Clusters, also Gruppen von Kunden mit ähnlichen Eigenschaften, identifizieren.

### Look for correlations in our engineered features

Bevor wir unsere Features und die anderen Daten zu den Kunden für das Clustering einsetzen, wollen wir überprüfen, ob bereits Korrelationen zwischen einzelnen Features und dem Kreditkarten Typ erkennbar sind.

**Schlussfolgerung:**

- Wie unten gut erkennbar, haben wir auf diesem Weg leider keine neuen direkten Korellationen zwischen dem Kartentyp und unseren engineerten Features gefunden.

#### Balance development per account in year before card issuance date

Es ist leider keine klare Korrelation zwischen der Vermögensentwicklung vor Kartenerhalt und dem Kartentyp erkennbar.

```{r}
# no clear correlaton between balance development and card visible...
ggplot(df_car_segments, aes(x = card.type,  y = eng.balance_dev_1y_before_card, color = card.type)) + 
  geom_boxplot() +
  scale_y_continuous(labels = label_number(suffix = " Kč")) +
  labs(title = "Balance development per account in year before card issuance date", x = "", y = "Balance Development", color = "Card Type")
```

#### Balance at card issuance per account

Kunden mit einem höheren Vermögen, haben eher die Goldkarte gewählt. Das ist jedoch eine Erkenntnis, die wir bereits vorher hatten.

```{r}
# looks like generally clients with more money on the bank went for the gold card!
# idea: target NA's with a lot of money (outliers!) and currently no card (NA)
ggplot(df_car_segments, aes(x = card.type, y = eng.balance_at_card_issuance, color = card.type)) + 
  geom_boxplot() +
  scale_y_continuous(labels = label_number(suffix = " Kč")) +
  labs(title = "Balance at card issuance per account", x = "", y = "Account Balance", color = "Card Type")
```

#### Balance development per account after card issuance

Auch zwischen der Vermögensentwicklung im Jahr nach der Austellung der Kreditkarte und dem Kartentyp lässt sich keine Korrelation ausmachen.

```{r}
# also not really a difference based on card here...
ggplot(df_car_segments, aes(x = card.type, y = eng.balance_dev_after_card, color = card.type)) + 
  geom_boxplot() +
  scale_y_continuous(labels = label_number(suffix = " Kč")) +
  labs(title = "Balance development per account after card issuance", x = "", y = "Balance Development", color = "Card Type")
```

#### Mean monthly transaction count per account

Eine leichte Tendenz zu mehr Transaktionen pro Monat mit dem Kartentyp Gold ist zu erkennen, jedoch nicht wirklich klar. Auch gibt es viele Kunden ohne Karte mit hohen Transaktionsraten.

```{r}
# minor tendency for more transactions with gold card
ggplot(df_car_segments, aes(x = card.type, y = eng.mean_trans_count_per_month, color = card.type)) + 
  geom_boxplot() +
  scale_y_continuous(labels = label_number(suffix = "")) +
  labs(title = "Mean monthly transaction count per account", x = "", y = "Transaction Count", color = "Card Type")
```

#### Median relative monthly balance development per account

Die monatliche, prozentuale Vermögensentwicklung eines Kontos scheint ebenfalls nicht direkt mit dem Kreditkarten Typ zu korellieren.

```{r}
# also not really difference based on card here...
ggplot(df_car_segments, aes(x = card.type, y = eng.median_relative_balance_dev_in_perc, color = card.type)) + 
  geom_boxplot() +
  scale_y_continuous(labels = label_number(suffix = "%")) +
  labs(title = "Median relative monthly balance development per account", x = "", y = "Balance Development", color = "Card Type")
```

### Applying K-Means

Für die Anwendung von K-Means orientieren wir uns am Buch "Practical Guide to Cluster Analysis in R" von Alboukadel Kassambara aus dem Jahr 2017. (https://sthda.com)

#### Data Preparation

Wir wählen die Variablen aus, auf die wir K-Means anwenden möchten, sampeln den Datensatz und skalieren die Werte.

```{r clustering-prepare-df}
# Create cluster input df
df_ci <- df_car_ext %>%
  ungroup() %>%
  select(
    disp.account_id,
    client.gender,
    client.age,
    order.sum_amount,
    loan.amount,
    eng.median_relative_balance_dev_in_perc,
    loan.has_loan,
    card.type
  ) %>%
  mutate(loan.amount = ifelse(is.na(loan.amount), 0, loan.amount)) %>%
  mutate(order.sum_amount = ifelse(is.na(order.sum_amount), 0, order.sum_amount))

summary(df_ci)

# Add ID column to easily identify clients afterwards
id <- 1:nrow(df_ci)
df_ci <- cbind(id, df_ci)

# Sample Dataset
set.seed(42)
df_cis.full <- df_ci %>% sample_n(2000)

# Remove factors for K-Means Input
df_cis.reduced <- df_cis.full %>%
  select(-id, -disp.account_id, -client.gender, -client.age, -loan.has_loan, -card.type)

# Scale Variables
df_cis.scaled <- scale(df_cis.reduced)
```

#### Assessing Clustering Tendency

Wir prüfen, ob unsere Daten überhaupt Gruppen mit Bedeutung beinhalten. Eine gute Methode hierzu ist die Hopkins Statistik.

Das Resultat kann wie folgt interpretiert werden:

- $H >= 0.5 - highly simlar dataset, not clusterable
- $H < 0.5 - clusterable

Unser Resultat für $H ist 0.02026995, was auf einen Datensatz hindeutet, in dem man gut Clusters erkennen kann. Dass die Clusters auch aussagekräftig sind, ist dadurch natürlich noch noch nicht bestätigt.

```{r clustering-check-for-tendency}
# commented out for performance reasons.
# hopkins(df_cis.scaled, n = nrow(df_cis.scaled) - 1)
```

Auch die Distance-Matrix zeigt zwischen den meisten Kunden Unterschiede, jedoch auch erkennbare Ähnlichkeiten. 
Rot deutet eine hohe Ähnlichkeit zwischen zwei Kunden an, und blau dementsprechend jeweils eine tiefe.

```{r clustering-distribution}
fviz_dist(dist(df_cis.scaled), show_labels = FALSE) + labs(title = "car data")
```

### Run K-Means

Nun wenden wir K-Means auf unseren skalierten Datensatz an. Mit der Elbow-Method haben wir für unser Clustering eine optimale Anzahl von 4 Clusters ausgemacht.

```{r clustering-kmeans}
set.seed(42)

# Find optimal cluster numbers
fviz_nbclust(df_cis.scaled, kmeans, method = "wss") +
  geom_vline(xintercept = 4, linetype = 2)

# K-Means Clustering
km.res <- kmeans(df_cis.scaled, 4, nstart = 25)

# Visualize using PCA to reduce dimensions
fviz_cluster(km.res, data = df_cis.scaled, ellipse.type = "euclid", star.plot = TRUE, ggtheme = theme_minimal())
```

Als nächstes fügen wir dem Dataframe df_cis.full, eine neue Spalte hinzu, die für jeden Kunden jeweils sein Cluster angibt.

```{r clustering-kmeans-results}
# Bind Results of Clustering to Input Data
df_cis.results <- cbind(df_cis.full, cluster = km.res$cluster) %>%
  mutate(cluster = as.factor(cluster))
head(df_cis.results)
```

### Interpreting K-Means Results

Bei der Interpretation der Bedeutung der unterschiedlichen Cluster, die uns K-Means ausgegeben hat, kann es helfen, die Mittelwerte von allen Features für die Daten in jedem Cluster zu berechnen. Genau das machen wir, und so lässt sich auf einen ersten Blick erkennen, dass:

- Der loan.amount Betrag in Cluster 3 im Vergleich zu den anderen Clusters sehr hoch ist. loan.has_loan zeigt, dass alle Kunden in diesem Cluster im Besitz eines Loans sind.
- Die Vermögensentwicklung eng.median_relative_balance_dev_in_perc bei allen Kunden im Cluster 1 im Vergleich zu den anderen Clustern äusserst stark zunimmt.

```{r clustering-kmeans-mean-input-dataset}
# Get mean values in each cluster group
aggregate(df_cis.full, by=list(cluster=km.res$cluster), mean)
```

#### Characterizing client properties by cluster

Mittels explorativer Datenanalyse können nun die Eigenschaften der Kunden in den Clusters charakterisiert werden.

Aus der untenstehenden Zusammenstellung von Plots können folgende Erkenntnisse gewonnen werden:

- In allen Clustern gibt es Kunden von allen Card Types, proportional ungefähr gleich.
- Wie schon in unseren Analysen zuvor deutlich wurde, hat das Geschlecht keinen Einfluss auf die finanzielle Situation der Kunden. In jedem Cluster sind die Geschlechter anteilsmässig  ähnlich stark vertreten.
- Während Cluster 2 und 3 nur Kunden bis 64 beinhalten, sind die Kunden in den Clustern 1 und 4 auch älter.
- In Cluster 3 sind nur Kunden gelandet, die ein grössers Darlehen bei der Bank haben.
- Die Vermögensentwicklung ist bei den Kuden in Cluster 1 auffallend positiv.

```{r}
ggplot(df_cis.results, aes(x = cluster, fill = card.type)) +
  geom_bar() +
  labs(title = "Number of clients in cluster by card type", x = "# Cluster", y = "# Number of Clients", fill = "Card Type")

ggplot(df_cis.results, aes(x = cluster, fill = loan.has_loan)) +
  geom_bar() +
  labs(title = "Number of clients in cluster by loan possession", x = "# Cluster", y = "# Number of Clients", fill = "Has Loan?")

ggplot(df_cis.results, aes(x = cluster, fill = client.gender)) +
  geom_bar() +
  labs(title = "Number of clients in cluster by gender", x = "# Cluster", y = "# Number of Clients", fill = "Has Loan?")

ggplot(df_cis.results, mapping=aes(x = cluster, y = client.age)) + 
  geom_violin() +
  labs(title = "Age distribution of clients by cluster", x = "# Cluster", y = "Client Age")

ggplot(df_cis.results, mapping=aes(x = cluster, y = loan.amount)) + 
  geom_violin() +
  labs(title = "Loan amount distribution of clients by cluster", x = "# Cluster", y = "Loan Amount") +
  scale_y_continuous(labels = label_number(suffix = " Kč", scale = 1e+0))

ggplot(df_cis.results, mapping=aes(x = cluster, y = eng.median_relative_balance_dev_in_perc)) + 
  geom_violin() +
  labs(title = "Med. rel. balance development (%) distribution", subtitle = "of clients by cluster", x = "# Cluster", y = "Median relative balance development (%)")
```

#### Distribution of clients in clusters by age and card type

Wir prüfen zusätzlich nach Alter, ob Kunden mit einem spezifischen Kreditkarten Typ oft in einem bestimmten Cluster gelandet sind. 
Wie auch hier klar ersichtlich wird auf dem folgenden Plot, ist dies nicht der Fall. Auf Cluster-Basis kann also keine Kreditkarten Empfehlung gemacht werden.

```{r}
ggplot(df_cis.results, aes(x = client.age, y = cluster, color = card.type)) +
  geom_jitter() +
  labs(title = "Distribution of clients in clusters by age and card type", x = "Client Age", y = "# Cluster", color = "Card Type")
```

#### Distribution of clients in clusters by age and loan possession

In diesem Plot wird nochmal deutlich, das in Cluster 3 alle Kunden im Besitz eines Darlehens von der Bank sind.

```{r}
ggplot(df_cis.results, aes(x = client.age, y = cluster, color = loan.has_loan)) +
  geom_jitter() +
  labs(title = "Distribution of clients in clusters by age and loan possession", x = "Client Age", y = "Cluster", color = "Has Loan?")
```

### Clustering Conclusion

Wir konnten aus den Clustern zwar einige Erkenntnisse über bestehende Gruppen in der Kundenbasis gewinnen, sehen darin jedoch für das Cross-Selling im Moment keinen Mehrwert. Mit unterschiedlichen anderen Input-Daten und anderen Methoden zur Interpretation, käme man möglicherweise hier weiter, und könnte die Resutate beispielsweise für Kundengruppenspezifisches Marketing nutzen.

Mit dem Hintergrund des Cross-Sellings belassen wir es jedoch bei den oben genannten Erkenntnissen, und bewegen uns weiter zu Supervised Learning. Dies mit dem Ziel, pro Kunde eine spezifische Vorhersage über die passende Kreditkarte zu treffen.

## Decision Tree

Mit den K-Means Clusters haben wir Unsupervised Learning abgedeckt. Nun möchten wir mittels eines Decision Trees, also Supervised Learning, eine klare Aussage darüber treffen können, welche welche Kreditkarte zu welchem Kunden passt. So werden einerseits Cross-Selling Möglichkeiten erkennbar, wo Kunden noch keine Kreditkarte haben, und andererseits Up-Selling, wo Kunden eine Classic Karte haben, aber wahrscheinlich mit der Gold Karte besser bedient wären.

### Data Preprocessing

Zuerst bereiten wir die Daten auf.

#### Reduce Dataset
```{r}
# Choose features
df_dt <- df_car_ext %>%
  ungroup() %>%
  select(
    client.age,
    client.gender,
    district.urban_ratio,
    order.sum_amount,
    loan.amount,
    eng.median_relative_balance_dev_in_perc,
    eng.balance_dev_1y_before_card,
    eng.balance_at_card_issuance,
    eng.mean_trans_count_per_month,
    loan.has_loan,
    card.type
  ) %>%
  mutate(loan.amount = ifelse(is.na(loan.amount), 0, loan.amount)) %>%
  mutate(order.sum_amount = ifelse(is.na(order.sum_amount), 0, order.sum_amount)) %>%
  mutate(card.type = as.character(card.type)) %>%
  replace_na(list(card.type = "na")) %>%
  mutate(card.type = as.factor(card.type)) 

# Add ID column to easily identify clients afterwards
id <- 1:nrow(df_dt)
df_dt <- cbind(id, df_dt)

# Save ones with na
df_dt.full <- df_dt

df_dt <- df_dt %>%
  filter(card.type != "na")

summary(df_dt)

glimpse(df_dt)
```

#### Shuffle Data

Wir definieren den Sample-Seed damit, die Daten nicht jedes Mal anders gemischt werden. Andernfalls variiert die Modellgenauigkeit immer und Verbesserungen nach Anpassungen sind nicht messbar!

```{r}
set.seed(42)
shuffle_index <- sample(1:nrow(df_dt))
df_dts <- df_dt[shuffle_index, ]
head(df_dts)
```

#### Split Train/Test Data

Damit wir den Decision Tree trainieren können, und anschliessend auch testen, ob er für neue Daten funktioniert, die er zuvor noch nie gesehen hat, teilen wir unseren Datensatz in Trainings- und Testdaten auf.

```{r}
# Function to help splitting train/test data.
create_train_test <- function(data, size = 0.8, train = TRUE) {
    n_row = nrow(data)
    total_row = size * n_row
    train_sample <-1: total_row
    if (train == TRUE) {
        return (data[train_sample, ])
    } else {
        return (data[-train_sample, ])
    }
}
```

Wir entscheiden uns für den 80/20 Split.

```{r}
# Split data for training and test 80/20.
df_dts_train <- create_train_test(df_dts, 0.8, train = TRUE)
df_dts_test <- create_train_test(df_dts, 0.8, train = FALSE)
dim(df_dts_train)
dim(df_dts_test)
```

#### Check Randomization

Bevor wir den Decision Tree trainieren, stellen wir sicher, dass die Daten gut randomisiert wurden, in dem wir im Training- sowie Test Datensatz den Anteil der Unterschiedlichen Kreditkarten Typen überprüfen. Dieser ist in beiden Datensätzen ungefähr gleich, und somit ist diese Vorassetzung erfüllt.

```{r}
prop.table(table(df_dts_train$card.type))
prop.table(table(df_dts_test$card.type))
```

### Train Decision Tree Model

Wir trainieren den Decision Tree darauf, alle Inputs nach dem Kartentyp zu Klassifizieren. So können wir die Daten eines Kunden als Input liefern, und erhalten anschliessend den Kreditkarten Typ, der nach der Logik des Decision Tree zum Kunden passt.

```{r}
df_dts.fitted <- rpart(card.type~., data = df_dts_train, method = "class")
rpart.plot(df_dts.fitted, extra = "auto", box.palette="Oranges")
```

### Test Model

Wir testen den Decision Tree, in dem wir ihn den Trainings- sowie Testdatensatz predicten lassen.

#### Predict on Datasets
```{r}
predict_seen_data <- predict(df_dts.fitted, df_dts_train, type = 'class')
predict_unseen_data <- predict(df_dts.fitted, df_dts_test, type = 'class')
```

#### Calculate Confusion Matrix

Die Confusion Matrix ist sehr wichtig für die Interepration der Resultate eines Decision Trees. Eine hohe Accuracy alleine sagt nichts aus.

Sie kann wie unten beschrieben interpretiert werden. FP steht für "False Positive", und TP entsprechend für "True Positive":

Classic   TP Classic    FP Gold   FP Junior
Gold      FP Classic    TP Gold   FP Junior
Junior    FP Classic    FP Gold   TP Junior

Ein Beispiel anhand der Classic Zeile aus den Resultaten der Prediction auf das Test Training Dataset:

- 118 aktuelle Kunden mit Classic Kreditkarten wurden korrekt als Classic klassifiziert.
- 2 aktuelle Kunden mit Classic Karte wurden fälschlicherweise als Gold klassifiziert.
- 2 aktuelle Kunden mit Classic Karte wurden fälschlicherweise als Junior klassifiziert.

```{r}
table_mat_seen <- table(df_dts_train$card.type, predict_seen_data)
table_mat_seen

table_mat_unseen <- table(df_dts_test$card.type, predict_unseen_data)
table_mat_unseen
```

#### Evaluate Model Accuracy

Unser Decision Tree erreicht eine erfreuliche Accurarcy von über 90% auf die Test- sowie die Trainingsdaten.

```{r}
model_accuracy_seen <- sum(diag(table_mat_seen)) / sum(table_mat_seen)
print(paste('Accuracy of Model on Train Data: ', round(model_accuracy_seen * 100, 2), '%'))

model_accuracy_unseen <- sum(diag(table_mat_unseen)) / sum(table_mat_unseen)
print(paste('Accuracy of Model on Test Data: ', round(model_accuracy_unseen * 100, 2), '%'))
```

Was die Confusion Matrix betrifft, konnten wir feststellen, dass die Vorhersagen für Junior und Classic sehr genau sind, aktuell jedoch noch zu viele Kunden, die eine Gold Kreditkarte haben, als Classic klassifiziert werden. Dies hängt sicherlich auch damit zusammen, dass keine klaren Grenzen zwischen den Kritierien Gold und Classic erkennbar ist, wie unsere vorherigen Analysen gezeigt haben. 

Für die Praxis bedeutet dies, dass wir mit dem Model bei der Empfehlung einer Karte nicht das komplette Potenzial für Gold Kreditkarten ausschöpfen. Da es jedoch darum geht, eine Cross-Selling Opportunität aufzuzeigen, und die Bank bereits viel gewinnt, sie mit wenig Risiko eine Classic Kreditkarte zusätzlich verkaufen kann, bewerten wir das unter diesem Kontext als unproblematisch.

Der Decision Tree erlaubt uns, mit hoher Zuversicht für jeden Kunden den passenden Typ von Kreditkarte zu bestimmen.

#### Predict for all clients

Wir führen die prediction auf unseren gesamten Datensatz aus.

```{r}
predict_full_data = predict(df_dts.fitted, df_dt.full, type = 'class')

df_dt.result = cbind(predict_full_data, df_dt.full)
```

## Creating customer list ranked by Risk Score

Nun wird es Zeit, unsere Erkenntnisse aus der vorhergegangenen Analyse in konkrete Cross-Selling Empfehlungen an die Bank umzuwandeln.

Wir generieren eine finale Liste mit einem Risk Score. Je höher der Score, desto geringer das Risiko im entsprechenden Geschäft für die Bank. Der Risk Score setzt sich dabei aus Summanden zusammen, die wir aus diversen engineerten Features und Resultaten der vorhergegangenen Analysen, die unser Customer Analytics Record beinhaltet, ableiten. Die Formel zur Berechnung stellt einen fundierten Startpunkt dar. Es ist jedoch angebracht, die Berechnug des Risk Scores basierend auf echten Erfahrungen damit, auszuwerten und laufend zu optimieren.

Der Risk Score gibt der Bank die Möglichkeit, die Kundenbasis nach Risiko, Relevanz und Verkaufspotential abzuarbeiten und so mit tiefem Risiko Cross-Selling zu betreiben.

```{r binding results to the df_car_segments df}
df_car_segments <- cbind(predict_full_data, df_car_segments)
```

```{r adding engineered features from credit check} 
df_credit_check_joinready <- df_credit_check %>% select(account_id, credit_check, avg_income, final_balance)
df_car_segments <- df_car_segments %>% left_join(df_credit_check_joinready, by = c("disp.account_id" = "account_id" ))
rm(df_credit_check_joinready)
df_car_segments <- df_car_segments %>% mutate(credit_check = as.factor(credit_check))
```

Beim definieren der Formel für den Risk Score haben wir folgende Überlegungen angestellt:

**Wahl der Attribute**

- Attribute wie zum Beispiel Alter und Geschlecht, haben wir in unseren Analysen als "nicht aussagekräftig" identifiziert, und für den Risk Score deshalb auch nicht verwendet.
- Es sind nicht für alle Kunden alle Attribute gegeben, es hat auch viele NA Werte. Auch diese sagen jedoch etwas aus, nämlich dass das entsprechende Produkt vom Kunden bisher nicht genutzt wird. Wir können mit diesen Informationen das Risiko besser einschätzen, deshalb verwenden wir auch solche Attribute.

**Relevante Vorhersagen**

- Die "Prediction" der passenden Kreditkarte unseres Decision Trees war mit ~90% sehr akkurat, jedoch vergibt diese jedem Kunden eine prediction "Junior", "Classic" oder "Gold" auf Basis seiner Eigenschaften, und berücksichtigt dabei das Risiko nicht. Wir können deshalb unsere Empfehlung nicht nur darauf basieren. Auch beachtet der Decision Tree keine fest definierten Logiken, wie die von der Bank vorgegebene Alterbeschränkung von 25 Jahren für die Junior Kreditkarte. Beim Risk Score führt eine Prediction von "Gold" zu +100 Punkten, und "Classic" oder "Junior" zu +50.
- Der Credit Check wird ebenfalls eingebunden. Dieser wird zwar auch mit das avg_income berechnet, berücksichtigt jedoch weitere Faktoren. Hier können wir je nach Kartenempfehlung Punkte geben, oder Punkte abziehen, wenn der Status "failed" ist.

**Relevante Attribute**

- Die Variable balance_at_card_issuance ist nur für Kunden mit Kreditkarten auf dem issuance date basierend. Für Kunden ohne Karte ist es der letzte bekannte Saldo. Das Vermögen ist in jedem Fall ausschlaggebend für die Vergabe einer Kreditkarte. Wir haben uns deshalb entschieden, das Vermögen durch 1000 zu dividieren, was für die meisten Kunden in +20 bis +100 Credit Score Punkten resultiert.
- Die Variable dev_before_card ist ebenfalls auch nur bei Kunden mit Kreditkarten auf das issued_date bezogen, bei Kunden ohne Karte ist es die Vermögensentwicklung im Jahr vor Ende der Aufzeichnungen. Die Vermögensveränderung ist ein wichtiges Attribut, jedoch kann es je nach Kunde unterschiedlich "viel bedeuten". Hat jemand 120k auf dem Konto und gibt 20k aus, so ist das nicht so wichtig, wie wenn jemand mit 25k plötzlich 20k ausgibt. Wir möchten es trotzdem stark gewichten und nehmen die selbe Berechnung wie beim Vermögen an (Division durch 1000).
 - Das avg_income ist beschrieben im Credit Check und wird hier ebenfalls als relevant betrachtet. Die Plots dazu haben gezeigt, dass das Attribut durchaus als näherungsweise akkurate Berechnung betrachtet werden kann. Da ein regelmässiges Einkommen die wichtigste Information für die Vergabe einer Kreditkarte ist, haben wir dieses Attribut nur durch 100 geteilt, und erhalten so zum Beispiel bei einem regelmässigen Einkommen von 8k +80 Credit Score Punkte.
- Hat ein Kunde einen laufenden Loan, so werden ihm die monatlichen Kosten / 100 vom Risk Score abgezogen, da wir dies gleichsetzen können mit dem Abzug vom monatlichem Einkommen (avg_income). Den Status des Loans haben wir hier nicht speziell abgefragt, da dieser im credit check geprüft wird und ein "failed" ausgeben würde wenn es Zahlungsprobleme gab, was zu einem Punkteabzug führt.
- Hat der Kunde ein Loan mit Status "ok", so erhält er +50 zum Risk Score. Da bereits ein Kredit gut verläuft, soll dies den obigen Malus etwas ausgleichen bei gut zahlenden Kunden, und denjenigen mit gut abgeschlossenem Loan einen Bonus geben.
- Als kleinen Bonus haben wir die enterprenurial_rate miteinbezogen, so dass eventuell der ein oder andere Kunde noch genau über die Kriteriengrenze rutschen kann. Dies mit dem Hintergrund, dass es bei einer besseren enterprenurial_rate statistisch eine gewisse Chance gibt, dass der Kunde mit Vorschüssen gut umgehen kann.

Die komplette Logik in der Berechnung des Risk Scores kann der untenstehenden Code Zelle entnommen werden.

```{r calculating risk score}
df_car_segments <- df_car_segments %>% 
  mutate(risk_score = if_else(
    predict_full_data=="classic" | predict_full_data=="junior",
    50, 100   ))%>%
      mutate(risk_score = if_else(is.na(risk_score), 0, risk_score))%>% 
  mutate(risk_score = if_else(
    !is.na(eng.balance_at_card_issuance),
    risk_score + round((eng.balance_at_card_issuance / 1000), digits = 0), risk_score
  )) %>% mutate(risk_score = if_else(
    !is.na(eng.balance_dev_1y_before_card),
    risk_score + round((eng.balance_dev_1y_before_card / 1000), digits = 0), risk_score
  )) %>% mutate(risk_score = if_else(
    !is.na(avg_income),
    risk_score + round((avg_income / 100),digits = 0), risk_score
  ))  %>% mutate(risk_score = if_else( !is.na(credit_check) &
    (credit_check == "classic" | credit_check =="junior"),
    risk_score + 25, risk_score
  ))  %>%  mutate(risk_score = if_else( !is.na(credit_check) &
    credit_check == "gold",
    risk_score + 50, risk_score
  )) %>% mutate(risk_score = if_else( !is.na(credit_check) &
    credit_check == "failed",
    risk_score - 100, risk_score
  )) %>%  mutate(
    risk_score = risk_score + (district.enterpren_rate/100)) %>% mutate(risk_score = if_else(
    grepl("running",loan.status),
    risk_score - round((loan.monthly_rate/100),digits = 0), risk_score
  )) %>% mutate(risk_score = if_else(
    grepl("_ok",loan.status),
    risk_score + 50, risk_score
  )) %>% mutate(risk_score = round(risk_score, digits = 0))

df_car_segments %>% arrange(desc(risk_score)) %>% sample_n(size=5)
```

Nachfolgende Violin Plots zeigen anschaulich unsere beiden Prediction Methoden (der auf manuellen, aus Analysen festgelegten Kriterien basierende Credit Score, und den Decision Tree) im Zusammenhang mit dem Risk Score auf. Es wird deutlich, dass die Anforderungen für Gold höher sind als für Junior und Classic Kreditkarten. Diese Kunden haben fast alle einen höheren Risk Score. Sie stellen somit ein geringeres Risiko für die Bank dar und sind entsprechend geeignet für die Gold Kreditkarte.

```{r plotting of risk_score internal check}
df_car_segments %>% ggplot(mapping=aes(x = credit_check, y = risk_score)) + 
  geom_violin() +
  labs(title = "Distribution of the Bank Clients by Predicted Card Type on Risk Score", subtitle = "(prediciton based on Credit Check)", x = "Predicted Card Type", y = "Risk Score")

df_car_segments %>% ggplot(mapping=aes(x = predict_full_data, y = risk_score)) + 
  geom_violin() +
  labs(title = "Distribution of the Bank Clients by Predicted Card Type on Risk Score", subtitle = "(prediciton based on Decision Tree)", x = "Predicted Card Type", y = "Risk Score")
```

### Add loan possibility

Nun möchten wir schauen, ob der Kunde nebst einer Kreditkarte auch das Potential für ein Darlehen erfüllt.

Wir sind bei den Loans etwas "strenger" als bei den Kreditkarten, da hier ein grosser Betrag ausgeliehen wird, welcher evtl. nicht mehr bezahlt werden kann, wobei bei Kreditkarten die Abrechnungen monatsweise sind, und das Risiko der Bank kleiner. Für das interpretieren der Liste soll beachtet werden, dass wir nur mit vorhandenen Daten arbeiten konnten. Hätten wir genauere Angaben zu regemässigem Einkommen, könnten wir die Vermögensveränderungen leichter gewichten und die Anzahl "loan recommendation" wäre vermutlich höher.

- Falls der Kunde bereits einen Loan hat und gut bezahlt, kann dieser auf einen Betrag, der im vertretbaren Risiko Rahmen liegt, erhöht werden.
- Ist der Risk-Score unter 125 (anhand dem Violin Plot oben festgelegt), empfehlen wir keinen Loan zu geben.
- Wenn der aktuelle Kontostand unter 25k liegt, wird ebenfalls kein Loan empfohlen. Wir haben hier einen Basiswert festgelegt, um eine gewisse Sicherheit in der Abzahlung zu gewährleisten.
- Hat der Kunde keine Karte, so wird die Vermögensentwicklung des letzten Jahres beurteilt. Ist diese negativ, so wird kein Kredit vergeben.
- Hat der Kunde eine Karte, so wird die Vermögensentwicklung 1 Jahr nach Erhalt der Kreditkarte beurteilt. Dies kann als Ansatz genommen werden, wie der Kunde mit "Kredit" umgeht. Ist diese Veränderung negativ, wird kein Loan empfohlen.
- Kunden, die nicht unter eines dieser Ausschlusskritieren fallen, kann ein Loan angeboten werden.

```{r adding loan recommendation}
df_car_segments <- df_car_segments %>% mutate(loan_applicable = if_else(
    loan.has_loan == TRUE,
    "no", "unknown"
  ))   %>% mutate(loan_applicable = if_else(
    loan_applicable=="unknown" & risk_score < 125,
    "no", loan_applicable
  ))  %>%  mutate(loan_applicable = if_else(
    loan_applicable=="unknown" & final_balance < 25000,
    "no", loan_applicable
  ))  %>%  mutate(loan_applicable = if_else(
    loan_applicable=="unknown" & card.has_card == FALSE & eng.balance_dev_1y_before_card < 0,
    "no", loan_applicable
  )) %>%  mutate(loan_applicable = if_else(
    loan_applicable=="unknown" & card.has_card == TRUE & eng.balance_dev_after_card < 0,
    "no", loan_applicable
  ))  %>%  mutate(loan_applicable = if_else(
    loan_applicable=="unknown",
    "yes", loan_applicable
  ))
```

# Results

## Cross-Selling Recommendations for the Bank

In folgender Tabelle, entfernen wir die in diesem Zusammenhang nicht mehr relevanten Attribute, und lassen unsere Cross-Selling Empfehlungen pro Kunde drin.

**Kreditkarten**:
- Anhand dem Decision Tree Resultat für die Kreditkarte (predict_full_data), sowie als Kontrolleinheit credit_check, empfehlen wir den Kreditkarten Typ.
- Für niemanden mit einem Risk Score unter 100 Punkten wird eine Kreditkarte empfohlen. So ergänzen wir das Decision Tree Resultat um ein Risk Management.
- Bei den Junior Karten kommen alle unter 25 Jahren in Frage, da für die Juniorkarten anhand der Analysen keine grossen Anforderungen gestellt werden. Der Risk Score bewertet dabei das Risiko.
- Auch bei Classic Karten stützen wir uns eher auf den Decision Tree
- Für die Gold Karten setzen wir auf die Empfehlung aus dem Decision Tree, da der Credit Check uns "zu viele" Gold Karten liefert (keine klaren Kriterien/Grenzen für die beiden Produkte vorhanden), und die Bank diese Karte als Premiumprodukt etwas exklusiver vergeben sollte.
- Wir haben für Kartenhalter mit "Classic" aber "Gold" potential die Empfehlung auf "Upselling" gesetzt.

**Loans**:
Bei den Loans haben wir bereits die Prüfung, ob ein Loan vergeben werden soll, gemacht. Im Falle eines "yes" schlagen wir als Maximumbetrag für einen Loan das 3-Fache von 80% des Vermögens vor (Eigenkapital muss ~1/4 der Darlehensgrösse betragen, und darf nicht mehr als 80% des Vermögens sein).

```{r generating final list with recommendations}
df_final_list <- df_car_segments %>% 
  select(disp.client_id, disp.account_id, client.gender, client.age, risk_score, loan_applicable, predict_full_data, credit_check, final_balance, eng.balance_dev_1y_before_card, eng.balance_at_card_issuance, eng.balance_dev_after_card, avg_income, loan.has_loan, loan.monthly_rate, loan.status, loan.amount, card.has_card, card.type, district.enterpren_rate) %>% 
  arrange(desc(risk_score))

df_final_list <- df_final_list %>% 
  mutate(card_recommendation = "unknown") %>% 
  mutate(card_recommendation = if_else(risk_score<100, "no", card_recommendation)) %>%
  mutate(card_recommendation = if_else(client.age < 25  & card_recommendation!="no", "junior", card_recommendation)) %>%
  mutate(card_recommendation = if_else(card_recommendation == "unknown" & predict_full_data == "gold" & credit_check == "gold", "gold", card_recommendation)) %>%
  mutate(card_recommendation = if_else(card_recommendation == "unknown" & predict_full_data == "gold" & credit_check == "classic", "gold", card_recommendation)) %>%
  mutate(card_recommendation = if_else(card_recommendation == "unknown" & predict_full_data == "gold" & credit_check == "junior", "junior", card_recommendation)) %>%
  mutate(card_recommendation = if_else(card_recommendation == "unknown" & predict_full_data == "classic" & credit_check == "classic", "classic", card_recommendation)) %>%
  mutate(card_recommendation = if_else(card_recommendation == "unknown" & predict_full_data == "classic" & credit_check == "gold", "classic", card_recommendation)) %>%
  mutate(card_recommendation = if_else(card_recommendation == "unknown" & predict_full_data == "classic" & credit_check == "junior", "junior", card_recommendation)) %>%
  mutate(card_recommendation = if_else(card_recommendation == "unknown" & predict_full_data == "junior" & credit_check == "junior", "junior", card_recommendation)) %>%
  mutate(card_recommendation = if_else(card_recommendation == "unknown" & predict_full_data == "junior" & credit_check == "gold", "junior", card_recommendation)) %>%
  mutate(card_recommendation = if_else(card_recommendation == "unknown" & predict_full_data == "junior" & credit_check == "classic", "classic", card_recommendation)) %>%
  mutate(card_recommendation = if_else(card_recommendation == "unknown" & credit_check == "failed", "no", card_recommendation)) %>%
  mutate(card_recommendation = if_else(card.has_card == TRUE & card_recommendation == "gold" & card.type == "classic", "upsell", card_recommendation)) %>%
  mutate(card_recommendation = if_else(card_recommendation != "upsell" & card.has_card == TRUE, paste("keep", as.character(card.type)), card_recommendation)) %>%
  mutate(card_recommendation = if_else(is.na(card_recommendation), as.character(predict_full_data), card_recommendation)) %>%
  mutate(loan_recommendation = if_else(loan_applicable == "no", "no", "unknown")) %>%
  mutate(loan_recommendation = if_else(loan_recommendation == "unknown", paste("up to ",  format(round_any((final_balance-(final_balance*0.2))*4, 10000, floor),scientific = FALSE)), loan_recommendation))%>%
  mutate(loan_recommendation = if_else(grepl("finished_ok",loan.status) & loan_recommendation == "no", paste("next loan up to",  format(round_any((final_balance-(final_balance*0.2))*4, 10000, floor),scientific = FALSE)), loan_recommendation  )) %>%
  mutate(loan_recommendation = if_else(grepl("running_ok",loan.status) & loan_recommendation == "no" & round_any(final_balance*4, 10000, floor)>loan.amount, paste("increase up to",  format(round_any((final_balance-(final_balance*0.2))*4, 10000, floor),scientific = FALSE)), loan_recommendation  )) %>%
  select(disp.client_id, client.age, risk_score,  card_recommendation, card.type, loan_recommendation, loan.amount) %>%
  arrange(desc(risk_score))

df_final_list <- df_final_list %>%
  mutate(card_recommendation = as.factor(card_recommendation))
```

Ein Sample der generierten Liste mit Cross-Selling Empfehlungen:

```{r}
df_final_list %>% sample_n(size = 25)
```

### Abschliessende Empfehlungen

- Wir empfehlen der Bank, unsere Cross-Selling Liste mit den Empfehlungen durchzuarbeiten nach Risiko Score und mit Marketing Strategien zu kombinieren (z.B. Junior Kreditkarten Angebote, Upselling-Kampagnen, etc.)
- Unsere Analysen aus Daten (siehe jeweils **Schlussfolgerungen:**) sollen für diese Kampagnen jeweils berücksichtigt werden. Es gibt z.B. Anzeichen dafür, dass ältere Kunden vermutlich weniger empfänglich sind für Kreditkarten als junge.
- Bei der Vergabe von Loans sollte die Bank genauere Angaben zum regelmässigen Einkommen beziehen, damit eine möglichst kurze Vertragsdauer erreicht wird. Unsere Analysen haben gezeigt, dass eine kürzere Vertragsdauer generell kleinere Risiken birgt.
- Gerade beim erhöhen des Darlehens ist Vorsicht geboten, da wir nicht wissen, wann die Stati der Loans erfasst werden. Hier natürlich immer den aktuellen Stand des derzeitigen Loans prüfen.
- Die anderen Eigenschaften, welche wir in den Schlussfolgerungen als wichtig empfunden haben, sind in den Risk Score eingeflossen. Prioritäten können deshalb von diesem abgeleitet werden.

Nachfolgend eine Übersicht der Kreditkarten Empfehlungen:

```{r}
summary(df_final_list$card_recommendation)
```

Export der Empfehlungen als csv.

```{r}
write.csv(df_final_list, "cross_selling_recommendations.csv", row.names = TRUE)
```


## Client Analytical Record

Für weitergehende Analysen, zum Beispiel mit anderen Modellen, kann der Client Analytical Record als Basis genommen werden. Darin sind alle relevanten Informationen zu den Bankkunden zusammengefasst.

```{r}
df_final_list_reduced <- df_final_list %>%
  select(disp.client_id, card_recommendation, loan_recommendation)

df_client_analytical_record <- df_car_segments %>%
  inner_join(df_final_list_reduced, by = "disp.client_id")

df_client_analytical_record <- df_client_analytical_record %>%
  rename(decision_tree_card_prediction = predict_full_data) %>%
  rename(credit_check_avg_income = avg_income) %>%
  relocate(credit_check_avg_income, .before = credit_check) %>%
  relocate(loan_applicable, .before = loan_recommendation) %>%
  select(-disp.disp_id, -bal_segment, -dev_segment, -dev_factor, -district.avg_salary, -district.urban_ratio, -district.enterpren_rate)
```

```{r}
write.csv(df_client_analytical_record, "client_analytical_record.csv", row.names = TRUE)
```

